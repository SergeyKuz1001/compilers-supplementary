import Collection;
import Array;
import List;
import Fun;
import Utils;

fun makeMemory (heap, freeLocs, newLoc, border) {
  fun allocate (value) {
    case freeLocs of
      {}               -> [makeMemory (addMap (heap, newLoc,  value), {},       newLoc+1, border), newLoc]
    | freeLoc:freeLocs -> [makeMemory (addMap (heap, freeLoc, value), freeLocs, newLoc,   border), freeLoc]
    esac
  }

  fun get (loc) {
    case findMap (heap, loc) of Some (res) -> res esac
  }

  fun set (loc, value) {
    makeMemory (addMap (heap, loc, value), freeLocs, newLoc, border)
  }

  fun free (locsSet) {
    makeMemory (
      foldMap (
        fun (newHeap, [loc, val_]) {
          if memSet (locsSet, loc)
          then newHeap
          else addMap (newHeap, loc, val_)
          fi
        },
        emptyMap (compare),
        heap),
      elements (union (locsSet, listSet (freeLocs, compare))),
      newLoc,
      border)
  }

  fun getAllLocsSet () {
    listSet (map (fst, bindings (heap)), compare)
  }

  fun gcCheckMemory () {
    newLoc <= border
  }

  fun gcUpdateBorder (f) {
    makeMemory (heap, freeLocs, newLoc, f (border))
  }

  [allocate, get, set, free, getAllLocsSet, gcCheckMemory, gcUpdateBorder]
}

public fun emptyMemory (border) {
  makeMemory (emptyMap (compare), {}, 0, border)
}

public fun fullMemory (size, border) {
  makeMemory (listMap (init (size, fun (i) { [i, 0] }), compare), {}, size, border)
}

public fun allocate (value) {
  [from, "memory", fun (mem) { mem [0] (value) }]
}

public fun get (loc) {
  [view, "memory", fun (mem) { mem [1] (loc) }]
}

public fun set (loc, value) {
  [on, "memory", fun (mem) { mem [2] (loc, value) }]
}

public fun free (locsSet) {
  [on, "memory", fun (mem) { mem [3] (locsSet) }]
}

public fun getAllLocsSet () {
  [view, "memory", fun (mem) { mem [4] () }]
}

public fun gcCheckMemory () {
  [view, "memory", fun (mem) { mem [5] () }]
}

public fun gcUpdateBorder (f) {
  [on, "memory", fun (mem) { mem [6] (f) }]
}

public fun setFromLoc (loc, valueLoc) {
  get (valueLoc) >>= fun (value) {
  set (loc, value) }
}

public fun createArray (elemLocs) {
  ARRAY (elemLocs.size, fun (i) { byIdx (elemLocs, i) })
}

public fun createSexp (tag, elemLocs) {
  SEXP (tag, elemLocs.size, fun (i) { byIdx (elemLocs, i) })
}

public fun getLocs (value) {
  case value of
    ARRAY (n, atFun) ->
      init (n, atFun)
  | SEXP (_, n, atFun) ->
      init (n, atFun)
  | _ ->
      {}
  esac
}

public fun getDeep (value) {
  case value of
    ARRAY (n, atFun) ->
      traverse (get >> getDeep, init (n, atFun)) >>
      [fmap, listArray]
  | SEXP (tag, n, atFun) ->
      traverse (get >> getDeep, init (n, atFun)) >>= fun (elems) {
      return (Sexp (tag, listArray (elems))) }
  | _ ->
      return (value)
  esac
}

public fun getElemLoc (arr, idx) {
  case arr of
    ARRAY (_, atFun) ->
      return (atFun (idx))
  | SEXP (_, _, atFun) ->
      return (atFun (idx))
  esac
}

public fun gcRun (topLocs) {
  fun walk (acc, loc) {
    if memSet (acc, loc)
    then
      return (acc)
    else
      get (loc) >>= fun (value) {
      case value of
        ARRAY     (n, atFun) -> foldM (walk, addSet (acc, loc), init (n, atFun))
      | SEXP (tag, n, atFun) -> foldM (walk, addSet (acc, loc), init (n, atFun))
      | _                    -> return (addSet (acc, loc))
      esac }
    fi
  }

  getAllLocsSet () >>= fun (allLocsSet) {
  foldM (walk, emptySet (compare), topLocs) >>= fun (avLocsSet) {
  return (diff (allLocsSet, avLocsSet)) >>= fun (zoLocsSet) {
  free (zoLocsSet) } } }
}
