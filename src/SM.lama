-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Utils;
import Collection;
import World;
import State;
import Memory;
import Cache;
import Parser;
import Lexer;
import Expr;
import Builtins;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  -- Shows a location (a reference to function argument, local or global variable)
  fun showLoc (d) {
    case d of
      Arg (i) -> sprintf ("arg[%d]", i)
    | Loc (i) -> sprintf ("loc[%d]", i)
    | Glb (x) -> sprintf ("%s", x)
    esac
  }

  case i of
    BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showLoc (x))
  | LDA    (x)       -> sprintf ("LDA %s", showLoc (x))
  | ST     (x)       -> sprintf ("ST %s", showLoc (x))
  | SEXP   (s, n)    -> sprintf ("SEXP ""%s"", %d", s, n)
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (l)       -> sprintf ("LABEL %s", l)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (Z, l)    -> sprintf ("CJMP_Z %s", l)
  | CJMP   (NZ, l)   -> sprintf ("CJMP_MZ %s", l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | PBEGIN (f, a, l) -> sprintf ("PBEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | PEND   (f)       -> sprintf ("PEND %s", f)
  | DUP              -> "DUP"
  | DROP             -> "DROP"
  | STRING (s)       -> sprintf ("STRING ""%s""", s)
  | ARRAY  (n)       -> sprintf ("ARRAY %d", n)
  | STA              -> "STA"
  | ELEM             -> "ELEM"
  | TO_HEAP          -> "TO_HEAP"
  esac
}

fun isSMInsn (i) {
  case i of
    BINOP  (_)       -> true
  | LD     (_)       -> true
  | LDA    (_)       -> true
  | ST     (_)       -> true
  | SEXP   (_, _)    -> true
  | CONST  (_)       -> true
  | LABEL  (_)       -> true
  | JMP    (_)       -> true
  | CJMP   (_, _)    -> true
  | CALL   (_, _)    -> true
  | BEGIN  (_, _, _) -> true
  | PBEGIN (_, _, _) -> true
  | GLOBAL (_)       -> true
  | END              -> true
  | PEND   (_)       -> true
  | DUP              -> true
  | DROP             -> true
  | STRING (_)       -> true
  | ARRAY  (_)       -> true
  | STA              -> true
  | ELEM             -> true
  | TO_HEAP          -> true
  | _                -> false
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];

  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabelPure (env, lab) {
  env [0] (lab)
}

-- Stack machine interpreter. Takes an environment, a world and a program,
-- returns a final output
fun eval (env, world, insns) {
  -- Global state maps names of global variables to values
  var globalMap, globalMapSize;

  -- Lookups a location in local/global states
  fun lookup (loc) {
    [view, "state", fun ([args, locs]) {
      case loc of
        Arg (i) -> args[i]
      | Loc (i) -> locs[i]
      | Glb (x) -> case findMap (globalMap, x) of Some (v) -> v esac
      esac
    }]
  }

  fun getState () {
    [view, "state", id]
  }

  fun setState (args, locs) {
    [on, "state", const ([args, locs])]
  }

  fun fromLabel (lab) {
    fromLabelPure (env, lab)
  }

  fun createLocal (a, l) {
    [from, "v_stack", [splitN, a]] >>
    [fmap, reverse] >>= fun (args) {
    traverse (allocate, args) >>= fun (argLocs) {
    replicateM (l, allocate (0)) >>= fun (locLocs) {
    return ([listArray (argLocs), listArray (locLocs)]) } } }
  }

  fun getAllGlobalValues () {
    return (init (globalMapSize, id))
  }

  fun getAllCStackValues () {
    [view, "state", id] >>= fun ([args, locs]) {
    [view, "c_stack", id] >>= fun (c_stack) {
    return (foldl (
      fun (acc, [args, locs, _]) { arrayList (args) +++ (arrayList (locs) +++ acc) },
      {},
      [args, locs, {}] : c_stack)) } }
  }

  fun getAllVStackValues () {
    [view, "v_stack", id] >>= fun (v_stack) {
    return (foldl (
      fun (acc, value) { getLocs (value) +++ acc },
      {},
      v_stack)) }
  }

  fun gcCheckAndRun () {
    gcCheckMemory () >>= fun (okMemory) {
    if okMemory
    then id
    else getAllGlobalValues () >>= fun (globalLocs) {
         getAllCStackValues () >>= fun (cStackLocs) {
         getAllVStackValues () >>= fun (vStackLocs) {
         gcRun (globalLocs +++ (cStackLocs +++ vStackLocs)) >>
         gcUpdateBorder (fun (border) { border + 10 }) } } }
    fi }
  }

  fun evalInsn (c, insn, insns) {
    doM (c,
      gcCheckAndRun () >>
      case insn of
        BINOP (op) ->
          [from, "v_stack", split2] >>
          [fmap, fun ([y, x]) { evalOp (op, x, y) }] >>
          [into, "v_stack", cons] >>
          return (insns)
      | LD (l) ->
          lookup (l) >>= fun (loc) {
          get (loc) >>
          [into, "v_stack", cons] >>
          return (insns) }
      | LDA (l) ->
          lookup (l) >>
          [into, "v_stack", cons] >>
          return (insns)
      | ST (l) ->
          [from, "v_stack", split1] >>= fun (v) {
          lookup (l) >>= fun (loc) {
          set (loc, v) >>
          [on, "v_stack", cons (v)] >>
          return (insns) } }
      | SEXP (tag, n) ->
          [from, "v_stack", [splitN, n]] >>
          [fmap, reverse] >>= fun (elems) {
          traverse (allocate, elems) >>
          [fmap, fun (elemLocs) { createSexp (tag, elemLocs) }] >>
          [into, "v_stack", cons] >>
          return (insns) }
      | CONST (n) ->
          [on, "v_stack", cons (n)] >>
          return (insns)
      | LABEL (l) ->
          return (insns)
      | JMP (l) ->
          return (fromLabel (l))
      | CJMP (Z, l) ->
          [from, "v_stack", split1] >>= fun (z) {
          return (if z == 0 then fromLabel (l) else insns fi) }
      | CJMP (NZ, l) ->
          [from, "v_stack", split1] >>= fun (z) {
          return (if z != 0 then fromLabel (l) else insns fi) }
      | CALL (l, n) ->
          case splitString (l) of
            ['L', name] ->
              getState () >>= fun ([args, locs]) {
              [on, "c_stack", cons ([args, locs, insns])] >>
              return (fromLabel (l)) }
          | ['E', name] ->
              [from, "v_stack", [splitN, n]] >>
              [fmap, reverse] >>= fun (args) {
              traverse (getDeep, args) >>= fun (args_) {
              evalBuiltin (name, args_) >>
              [into, "v_stack", cons] >>
              return (insns) } }
          | ['M', _] ->
              [on, "c_stack", cons ([[], [], {}])] >>
              return (fromLabel (l))
          esac
      | BEGIN (n, a, l) ->
          createLocal (a, l) >>= fun ([args, locs]) {
          setState (args, locs) >>
          return (insns) }
      | PBEGIN (n, a, l) ->
          createLocal (a, l) >>= fun ([args, locs]) {
          traverse (get, arrayList (args)) >>= fun (params) {
          getCache (n : params) >>= fun (foundRes) {
          case foundRes of
            None ->
              setState (args, locs) >>
              return (insns)
          | Some (res) ->
              [on, "v_stack", cons (res)] >>
              [from, "c_stack", split1] >>= fun ([_, _, insns]) {
              return (insns) }
          esac } } }
      | END ->
          [view, "c_stack", size] >>=
          [bool,
            [from, "c_stack", split1] >>= fun ([args, locs, insns]) {
            setState (args, locs) >>
            return (insns) },
            return ({}) ]
      | PEND (n) ->
          getState () >>
          [intoAll, fun ([args, _]) { traverse (get, arrayList (args)) }] >>= fun (params) {
          [from, "c_stack", split1] >>= fun ([args, locs, insns]) {
          setState (args, locs) >>
          [view, "v_stack", hd] >>
          [intoAll, fun (res) { setCache (n : params, res) }] >>
          return (insns) } }
      | DUP ->
          [view, "v_stack", hd] >>
          [into, "v_stack", cons] >>
          return (insns)
      | DROP ->
          [on, "v_stack", tl] >>
          return (insns)
      | STRING (s) ->
          traverse (allocate, init (s.length, fun (i) { s [i] })) >>
          [fmap, createArray] >>
          [into, "v_stack", cons] >>
          return (insns)
      | ARRAY (n) ->
          [from, "v_stack", [splitN, n]] >>
          [fmap, reverse] >>= fun (elems) {
          traverse (allocate, elems) >>
          [fmap, createArray] >>
          [into, "v_stack", cons] >>
          return (insns) }
      | STA ->
          [from, "v_stack", split3] >>= fun ([v, i, a]) {
          (case i of
            ToHeap -> return (a)
          | _ -> getElemLoc (a, i)
          esac) >>
          [intoAll, [set, v]] >>
          [on, "v_stack", cons (v)] >>
          return (insns) }
      | ELEM ->
          [from, "v_stack", split2] >>= fun ([i, a]) {
          getElemLoc (a, i) >>= fun (loc) {
          get (loc) >>
          [into, "v_stack", cons] >>
          return (insns) } }
      | TO_HEAP ->
          [on, "v_stack", cons (ToHeap)] >>
          return (insns)
      esac
    )
  }

  -- Core interpreter: takes a configuration and a program, returns a configuration
  fun eval (c, insns) {
    var cc = c, ci = insns, cci;
    while ci.size do
      cci := evalInsn (cc, ci.hd, ci.tl);
      cc := cci.fst;
      ci := cci.snd
    od;
    cc
  }

  case
    insns . splitWhileSome (
      fun (insn) {
        case insn of
          GLOBAL (name) -> Some (name)
        | _ -> None
        esac
      })
    of [insns, glbs] ->
      var memory = fullMemory (glbs.size, 50), cache = emptyCache ();
      globalMap := listMap (glbs.enumerate, compare);
      globalMapSize := glbs.size;
      getOutput (eval (
        createData([
          "v_stack", {},
          "c_stack", {},
          "state",   [[], []],
          "memory",  memory,
          "cache",   cache,
          "world",   world
        ]), insns))
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), createWorld (input), insns)
}

-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel () {
    [makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions), sprintf ("L%d", nLabels)]
  }

  -- Adds a new function
  fun rememberFun (fLabel, args, body) {
    makeCompEnv (nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun (fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope () {
    makeCompEnv (nLabels, scopeDepth+1, enterScopePure (state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope () {
    makeCompEnv (nLabels, scopeDepth-1, leaveScopePure (state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg (name) {
    makeCompEnv (nLabels, scopeDepth, addNamePure (state, name, Arg (nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a variable in the scope
  fun addVar (name) {
    if isGlobal ()
    then makeCompEnv (nLabels, scopeDepth, addNamePure (state, name, Glb (name, true)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addNamePure (state, name, Loc (nLocals, true)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a value in the scope
  fun addVal (name) {
    if isGlobal ()
    then makeCompEnv (nLabels, scopeDepth, addNamePure (state, name, Glb (name, false)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addNamePure (state, name, Loc (nLocals, false)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun (name, fLabel, nargs) {
    makeCompEnv (nLabels, scopeDepth, addNamePure (state, name, Fun (fLabel, nargs)), nLocals, nArgs, functions)
  }

  -- Enters a function
  fun beginFun (state) {
    makeCompEnv (nLabels, 2, enterFunctionPure (state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns () {
    [makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, {}), functions]
  }

  -- Lookups variable
  fun lookupVar (name) {
    case lookupPure (state, name) of
      Loc (i, true) -> Loc (i)
    | Glb (x, true) -> Glb (x)
    | _             -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
    esac
  }

  -- Lookups value
  fun lookupVal (name) {
    case lookupPure (state, name) of
      Loc (i, _) -> Loc (i)
    | Glb (x, _) -> Glb (x)
    | Arg (i)    -> Arg (i)
    | _          -> error (sprintf ("the name ""%s"" does not designate a value", name), getLoc (name))
    esac
  }
  
  -- Lookups a name of a function
  fun lookupFun (name) {
    case lookupPure (state, name) of
      x@Fun (_, _) -> x
    | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals () {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel (name) {
     if isGlobal ()
     then [makeCompEnv (nLabels  , scopeDepth, state, nLocals, nArgs, functions), bool (compare (name, "__main__") == 0, sprintf ("Main"), sprintf ("L%s", name))]
     else [makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions), sprintf ("L%s_%d", name, nLabels)]
     fi
  }

  -- Checks if the current scope is a global
  fun isGlobal () {
    scopeDepth == 2
  }

  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   addVal,
   beginFun,
   getFuns,
   lookupVar,
   lookupVal,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv () {
  makeCompEnv (0, 0, emptyState (), 0, 0, {})
}

-- Accessor functions
fun genLabel () {
  [from, "compEnv", fun (env) { env [0] () }]
}

fun rememberFun (name, args, body) {
  [on, "compEnv", fun (env) { env [1] (name, args, body) }]
}

fun beginScopePure (env) {
  env [2] ()
}

fun beginScope () {
  [on, "compEnv", fun (env) { env [2] () }]
}

fun endScope () {
  [on, "compEnv", fun (env) { env [3] () }]
}

fun addArg (name) {
  [on, "compEnv", fun (env) { env [4] (name) }]
}

fun addVar (name) {
  [on, "compEnv", fun (env) { env [5] (name) }]
}

fun addVal (name) {
  [on, "compEnv", fun (env) { env [6] (name) }]
}

fun beginFun (state) {
  [on, "compEnv", fun (env) { env [7] (state) }]
}

fun getFuns () {
  [from, "compEnv", fun (env) { env [8] () }]
}

fun lookupVar (name) {
  [view, "compEnv", fun (env) { env [9] (name) }]
}

fun lookupVal (name) {
  [view, "compEnv", fun (env) { env [10] (name) }]
}

fun lookupFun (name) {
  [view, "compEnv", fun (env) { env [11] (name) }]
}

fun getLocals () {
  [view, "compEnv", fun (env) { env [12] () }]
}

fun genFunLabel (name) {
  [from, "compEnv", fun (env) { env [13] (name) }]
}

fun addFunPure (env, name, fLabel, nargs) {
  env [14] (name, fLabel, nargs)
}

fun addFun (name, fLabel, nargs) {
  [on, "compEnv", fun (env) { env [14] (name, fLabel, nargs) }]
}

fun isGlobal () {
  [view, "compEnv", fun (env) { env [15] () }]
}

-- Helper function: adds a bunch of arguments
fun addArgs (names) {
  traverse_ (addArg, names)
}

-- Helper function: adds a bunch of local variables
fun addVars (names) {
  traverse_ (addVar, names)
}

-- Helper function: adds a bunch of locals values
fun addVals (names) {
  traverse_ (addVal, names)
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  fun emptyCode () {
    emptyBuffer ()
  }

  fun addCode (code) {
    [on, "codeBuf", [bool (isSMInsn (code), infix <+, infix <+>), code]]
  }

  fun changeCode (code) {
    [from, "codeBuf", fun (code_) { [code, code_] }]
  }

  fun genNewLabel () {
    genLabel () >>
    [fmap, [with, false]] >>
    [into, "labels", cons]
  }

  fun getLastLabel () {
    [from, "labels", fun ([lbl, lblU] : lbls) { [[lbl, true] : lbls, lbl] }]
  }

  fun setLastLabel () {
    [from, "labels", split1] >>
    [into, "codeBuf", fun ([lbl, lblU]) { bool (lblU, [infix <+, LABEL (lbl)], id) }]
  }

  fun withNewLabel (fdf) {
    genLabel () >>=
    fdf
  }

  fun withLabel (lbl, df) {
    [on, "labels", cons ([lbl, true])] >>
    df >>
    [on, "labels", tl]
  }

  fun depure (body) {
    case body of
      Pure (body)   -> [body, true]
    | Impure (body) -> [body, false]
    esac
  }

  fun compile (env, expr) {
    doM (env,
      genNewLabel () >>
      [genCode, expr] >>
      setLastLabel ()
    )
  }

  fun genCode (env, expr) {
    doM (env,
      case expr of
        Assn (r, v) ->
          [compile, r] >>
          [compile, v] >>
          addCode (STA)
      | Set (x, v) ->
          lookupVal (x) >>= fun (r) {
          [compile, v] >>
          addCode (ST (r)) }
      | Seq (exp1, exp2) ->
          [compile, exp1] >>
          [genCode, exp2]
      | Skip ->
          id
      | If (cond, tbr, ebr) ->
          withNewLabel (fun (lbl) {
            [compile, cond] >>
            addCode (CJMP (Z, lbl)) >>
            [genCode, tbr] >>
            getLastLabel () >>
            [intoAll, fun (lbl2) { addCode (JMP (lbl2)) }] >>
            addCode (LABEL (lbl)) >>
            [genCode, ebr]
          })
      | While (cond, body) ->
          withNewLabel (fun (lbl) {
            addCode (LABEL (lbl)) >>
            [compile, cond] >>
            getLastLabel () >>
            [intoAll, fun (lbl2) { addCode (CJMP (Z, lbl2)) }] >>
            withLabel (lbl, [genCode, body]) >>
            addCode (JMP (lbl))
          })
      | DoWhile (body, cond) ->
          withNewLabel (fun (lbl) {
            addCode (LABEL (lbl)) >>
            [compile, body] >>
            [compile, cond] >>
            addCode (CJMP (NZ, lbl))
          })
      | Var (x) ->
          lookupVal (x) >>= fun (v) {
          addCode (LD (v)) }
      | Ref (x) ->
          lookupVar (x) >>= fun (r) {
          addCode (LDA (r)) >>
          addCode (TO_HEAP) }
      | Const (num) ->
          addCode (CONST (num))
      | Binop (op, l, r) ->
          [compile, l] >>
          [compile, r] >>
          addCode (BINOP (op))
      | Scope (defs, exp) ->
          beginScope () >>
          traverse (
            fun (def) {
              case def of
                Var (names) ->
                  addVars (names) >>
                  isGlobal () >>=
                  [bool,
                    traverse (
                      fun (name) { return (addCode (GLOBAL (name))) },
                      names),
                    return ({})]
              | Val (names) ->
                  addVals (names) >>
                  isGlobal () >>=
                  [bool,
                    traverse (
                      fun (name) { return (addCode (GLOBAL (name))) },
                      names),
                    return ({})]
              | Fun (name, args, body) ->
                  genFunLabel (name) >>= fun (lbl) {
                  addFun (name, lbl, args.size) >>
                  return ({ rememberFun (lbl, args, body) }) }
              esac
            },
            defs) >>= fun (init) {
          sequence_ (flatten (init)) >>
          [compile, exp] >>
          isGlobal () >>
          [intoAll, [bool,
            addCode (END),
            id]] >>
          getFuns () >>= fun (fs) {
          traverse_ (
            fun (Fun (lbl, args, body, state)) {
              case depure (body) of [body, isPure] ->
              changeCode (emptyCode ()) >>= fun (savedCode) {
              beginFun (state) >>
              addArgs (args) >>
              [compile, body] >>
              getLocals () >>= fun (locsAmt) {
              changeCode (savedCode) >>= fun (funCode) {
              addCode (LABEL (lbl)) >>
              addCode (if isPure then PBEGIN (lbl, args.size, locsAmt) else BEGIN (lbl, args.size, locsAmt) fi) >>
              addCode (funCode) >>
              addCode (if isPure then PEND (lbl) else END fi) } } } esac
            },
            fs) >>
          endScope () } }
      | Call (name, exps) ->
          traverse_ (compile . ap, exps) >>
          lookupFun (name) >>= fun (Fun (lbl, nargs)) {
          if nargs == exps.size
          then addCode (CALL (lbl, nargs))
          else const (error (sprintf ("amount of arguments of function %s mismatch (expected: %d, actual: %d)", name.string, nargs, exps.size), getLoc (name)))
          fi }
      | Ignore (exp) ->
          [compile, exp] >>
          addCode (DROP)
      | String (s) ->
          addCode (STRING (s))
      | Array (exps) ->
          traverse_ (compile.ap, exps) >>
          addCode (ARRAY (exps.size))
      | Sexp (name, exps) ->
          traverse_ (compile.ap, exps) >>
          addCode (SEXP (name, exps.size))
      | Elem (arr, idx) ->
          traverse_ (compile.ap, {arr, idx}) >>
          addCode (ELEM)
      | ElemRef (arr, idx) ->
          traverse_ (compile.ap, {arr, idx})
      esac
    )
  }

  fun mainization (stmt) {
    case stmt of
      Scope (defs, expr) -> Scope (Fun ("__main__", {}, Impure (expr)) : defs, Call ("__main__", {}))
    | _ -> Scope ({Fun ("__main__", {}, Impure (stmt))}, Call ("__main__", {}))
    esac
  }

  gets (
    compile (
      createData ([
        "compEnv", initCompEnv ().beginScopePure
                                 .addFunPure ("read",   "Eread",   0)
                                 .addFunPure ("write",  "Ewrite",  1)
                                 .addFunPure ("length", "Elength", 1),
        "labels", {},
        "codeBuf", emptyCode ()
      ]),
      mainization (stmt)),
    "codeBuf",
    getBuffer)
}
