-- Stack machine.

import Array;
import List;
import Fun;
import Collection;
import World;
import State;
import Expr;
import Buffer;
import Fun;
import Utils;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ         -> "READ"
  | WRITE        -> "WRITE"
  | BINOP (s)    -> sprintf ("BINOP %s", s)
  | LD    (x)    -> sprintf ("LD %s", x)
  | LDA   (x)    -> sprintf ("LDA %s", x)
  | ST    (x)    -> sprintf ("ST %s", x)
  | STI          -> "STI"
  | CONST (n)    -> sprintf ("CONST %d", n)
  | LABEL (s)    -> sprintf ("LABEL %s", s)
  | JMP   (l)    -> sprintf ("JMP %s", l)
  | CJMP  (c, l) -> sprintf ("CJMP_%s  %s", c.string, l)
  | DUP          -> "DUP"
  | DROP         -> "DROP"  
  esac
}

fun isSMInsn (i) {
  case i of
    READ         -> true
  | WRITE        -> true
  | BINOP (_)    -> true
  | LD    (_)    -> true
  | LDA   (_)    -> true
  | ST    (_)    -> true
  | STI          -> true
  | CONST (_)    -> true
  | LABEL (_)    -> true
  | JMP   (_)    -> true
  | CJMP  (_, _) -> true
  | DUP          -> true
  | DROP         -> true
  | _            -> false
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];
  
  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

fun evalInsn (c, env, i) {
  case i of
    READ ->
      -- c . fromTrd (readWorld) . intoFst (cons) . withNone
      withNone (intoFst (fromTrd (c, readWorld), cons))
  | WRITE ->
      -- c . fromFst (split1) . intoTrd (writeWorld.curry) . withNone
      withNone (intoTrd (fromFst (c, split1), curry (writeWorld)))
  | BINOP (op) ->
      -- c . fromFst (split2) . smap (fun ([y, x]) { evalOp (op, x, y) }) . intoFst (cons) . withNone
      withNone (intoFst (smap (fromFst (c, split2), fun ([y, x]) { evalOp (op, x, y) }), cons))
  | LD (x) ->
      -- c . fromSnd ([withFunc, apply (x)]) . intoFst (cons) . withNone
      withNone (intoFst (fromSnd (c, [withFunc, apply (x)]), cons))
  | LDA (x) ->
      -- c . onFst (cons (REF (x))) . withNone
      withNone (onFst (c, cons (REF (x))))
  | ST (x) ->
      -- c . fromFst (split1) . smap (fun (z) { [x, z] }) . intoSnd ((infix <-).curryFlip) . withNone
      withNone (intoSnd (smap (fromFst (c, split1), fun (z) { [x, z] }), curryFlip (infix <-)))
  | STI ->
      -- c . fromFst (split2) . smap (fun ([v, REF(x)]) { [x, v] }) . underSnd ((infix <-).curryFlip) . intoFst (snd >> cons) . withNone
      withNone (intoFst (underSnd (smap (fromFst (c, split2), fun ([v, REF(x)]) { [x, v] }), curryFlip (infix <-)), snd >> cons))
  | CONST (n) ->
      -- c . onFst (cons (n)) . withNone
      withNone (onFst (c, cons (n)))
  | LABEL (_) ->
      -- c . withNone
      withNone (c)
  | JMP (l) ->
      -- c . withSome (env . fromLabel (l))
      withSome (c, fromLabel (env, l))
  | CJMP (Z, l) ->
      -- c . fromFst (split1) . smap (fun (z) { bool (z == 0, Some (env . fromLabel (l)), None) })
      smap (fromFst (c, split1), fun (z) { bool (z == 0, Some (fromLabel (env, l)), None) })
  | CJMP (NZ, l) ->
      -- c . fromFst (split1) . smap (fun (z) { bool (z != 0, Some (env . fromLabel (l)), None) })
      smap (fromFst (c, split1), fun (z) { bool (z != 0, Some (fromLabel (env, l)), None) })
  | DUP ->
      -- c . fromFst ([withFunc, hd]) . intoFst (cons) . withNone
      withNone (intoFst (fromFst (c, [withFunc, hd]), cons))
  | DROP ->
      -- c . onFst (tl) . withNone
      withNone (onFst (c, tl))
  esac
}

-- Stack machine interpreter. Takes an environment, an SM-configuration and a program,
-- returns a final configuration
fun eval (env, c, insns) {
  case insns of
    {} -> c
  | insn : oinsns ->
      case evalInsn (c, env, insn) of [c, mCont] ->
        eval (env, c, mCont . fromMaybe (oinsns))
      esac
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval (initEvalEnv (insns), [{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compilation environment: generates labels
fun makeCompEnv (n) {
  [fun () {
     [makeCompEnv (n+1), sprintf ("L%d", n)]
  }]
}

fun initCompEnv () {
  makeCompEnv (0)
}

-- Accessor function: generates one label
fun genLabel (env) {
  env [0] ()
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (expr) {
  fun addCode (env, code) {
    -- env . onTrd ([bool (isSMInsn (code), infix <+, infix <+>), code])
    onTrd (env, [bool (isSMInsn (code), infix <+, infix <+>), code])
  }

  fun genNewLabel (env) {
    -- env . fromFst (genLabel) . smap ([with, false]) . intoSnd (cons)
    intoSnd (smap (fromFst (env, genLabel), [with, false]), cons)
  }

  fun getLastLabel (env) {
    -- env . fromSnd (fun ([lbl, _] : lblis) { [[lbl, true] : lblis, lbl] })
    fromSnd (env, fun ([lbl, _] : lblis) { [[lbl, true] : lblis, lbl] })
  }

  fun setLastLabel (env) {
    -- env . fromSnd (fun (lbli : lblis) { [lblis, lbli] }) . intoTrd (fun ([lbl, lblU]) { bool (lblU, [infix <+, LABEL (lbl)], id) })
    intoTrd (fromSnd (env, fun (lbli : lblis) { [lblis, lbli] }), fun ([lbl, lblU]) { bool (lblU, [infix <+, LABEL (lbl)], id) })
  }

  fun withNewLabel (env, fdf) {
    -- env . fromFst (genLabel) . into (fdf)
    into (fromFst (env, genLabel), fdf)
  }

  fun withLabel (env, lbl, df) {
    -- env . onSnd (cons ([lbl, true])) . on (df) . onSnd (tl)
    onSnd (on (onSnd (env, cons ([lbl, true])), df), tl)
  }

  fun compile (env, expr) {
    -- env . genNewLabel . genCode (expr) . setLastLabel
    setLastLabel (genCode (genNewLabel (env), expr))
  }

  fun genCode (env, expr) {
    on (env,
      case expr of
        Assn (r, v) ->
          [compile, r] >>
          [compile, v] >>
          [addCode, STI]
      | Seq (exp1, exp2) ->
          [compile, exp1] >>
          [genCode, exp2]
      | Skip ->
          id
      | Read (x) ->
          [addCode, READ] >>
          [addCode, ST (x)]
      | Write (exp) ->
          [compile, exp] >>
          [addCode, WRITE]
      | If (cond, tbr, ebr) ->
          [withNewLabel, fun (lbl) {
            [compile, cond] >>
            [addCode, CJMP (Z, lbl)] >>
            [genCode, tbr] >>
            ((fun (lbl2) { [addCode, JMP (lbl2)] }) =<< getLastLabel) >>
            [addCode, LABEL (lbl)] >>
            [genCode, ebr]
          }]
      | While (cond, body) ->
          [withNewLabel, fun (lbl) {
            [addCode, LABEL (lbl)] >>
            [compile, cond] >>
            ((fun (lbl2) { [addCode, CJMP (Z, lbl2)] }) =<< getLastLabel) >>
            [withLabel, lbl, [genCode, body]] >>
            [addCode, JMP (lbl)]
          }]
      | DoWhile (body, cond) ->
          [withNewLabel, fun (lbl) {
            [addCode, LABEL (lbl)] >>
            [compile, body] >>
            [compile, cond] >>
            [addCode, CJMP (NZ, lbl)]
          }]
      | Var (x) ->
          [addCode, LD (x)]
      | Ref (x) ->
          [addCode, LDA (x)]
      | Const (num) ->
          [addCode, CONST (num)]
      | Binop (op, l, r) ->
          [compile, l] >>
          [compile, r] >>
          [addCode, BINOP (op)]
      | Ignore (exp) ->
          [compile, exp] >>
          [addCode, DROP]
      esac
    )
  }

  case compile ([initCompEnv (), {}, emptyBuffer ()], expr) of
    [_, _, code] -> getBuffer $ code
  esac
}
