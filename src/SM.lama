-- Stack machine.

import Ref;
import Array;
import List;
import Fun;
import Utils;
import Collection;
import World;
import State;
import Parser;
import Lexer;
import Expr;
import Buffer;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  -- Shows a location (a reference to function argument, local or global variable)
  fun showLoc (d) {
    case d of
      Arg (i) -> sprintf ("arg[%d]", i)
    | Loc (i) -> sprintf ("loc[%d]", i)
    | Glb (x) -> x
    | x       -> sprintf ("???[%s]", x)
    esac
  }

  case i of
    READ             -> "READ"
  | WRITE            -> "WRITE"
  | BINOP  (s)       -> sprintf ("BINOP %s", s)
  | LD     (x)       -> sprintf ("LD %s", showLoc (x))
  | LDA    (x)       -> sprintf ("LDA %s", showLoc (x))
  | ST     (x)       -> sprintf ("ST %s", showLoc (x))
  | STI              -> "STI"
  | CONST  (n)       -> sprintf ("CONST %d", n)
  | LABEL  (l)       -> sprintf ("LABEL %s", l)
  | JMP    (l)       -> sprintf ("JMP %s", l)
  | CJMP   (Z, l)    -> sprintf ("CJMP_Z %s", l)
  | CJMP   (NZ, l)   -> sprintf ("CJMP_MZ %s", l)
  | CALL   (f, n)    -> sprintf ("CALL %s, %d", f, n)
  | BEGIN  (f, a, l) -> sprintf ("BEGIN %s, %d, %d", f, a, l)
  | GLOBAL (x)       -> sprintf ("GLOBAL %s", x)
  | END              -> sprintf ("END")
  | DUP              -> "DUP"
  | DROP             -> "DROP"
  esac
}

fun isSMInsn (i) {
  case i of
    READ             -> true
  | WRITE            -> true
  | BINOP  (_)       -> true
  | LD     (_)       -> true
  | LDA    (_)       -> true
  | ST     (_)       -> true
  | STI              -> true
  | CONST  (_)       -> true
  | LABEL  (_)       -> true
  | JMP    (_)       -> true
  | CJMP   (_, _)    -> true
  | CALL   (_, _)    -> true
  | BEGIN  (_, _, _) -> true
  | GLOBAL (_)       -> true
  | END              -> true
  | DUP              -> true
  | DROP             -> true
  | _                -> false
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

-- Evaluation environment: keeps a mapping between labels and (sub)programs
fun initEvalEnv (insns) {
  var map =
    fix (fun (rec) {
          fun ([m, insns]) {
            case insns of
              {}               -> m
            | LABEL (lab) : tl -> rec ([addMap (m, lab, insns), tl])
            | _ : tl           -> rec ([m, tl])
            esac
          }
        }) $ [emptyMap (compare), insns];

  [fun (l) {
     case findMap (map, l) of Some (insns) -> insns esac
  }]
}

-- Accessor function
fun fromLabel (env, lab) {
  env [0] (lab)
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  fun makeState (a, l, gA, gM) {
    [initArray (a, const (0)), initArray (l, const (0)), gA, gM]
  }

  -- Lookups a location in local/global states
  fun lookup ([args, locs, glbs, glbsMap], loc) {
    case loc of
      Arg (i) -> args[i]
    | Loc (i) -> locs[i]
    | Glb (x) -> glbs[glbsMap . assoc (x) . fromMaybe (-1)]
    esac
  }

  -- Assigns a value to a location
  fun assign ([args, locs, glbs, glbsMap], loc, v) {
    case loc of
      Arg (i) -> args[i] := v
    | Loc (i) -> locs[i] := v
    | Glb (x) -> glbs[glbsMap . assoc (x) . fromMaybe (-1)] := v
    esac
  }

  fun createLocal (env, a, l) {
    doM (env,
      [from, "v_stack", [splitN, a]] >>
      [fmap,
        reverse >>
        listArray >>
        [with, initArray (l, const (0))]]
    )
  }

  fun getLocal ([args, locs, _, _]) {
    [args, locs]
  }

  fun setLocal ([_, _, glbs, glbsMap], args, locs) {
    [args, locs, glbs, glbsMap]
  }

  fun evalInsn (env, insn) {
    doM (env,
      case insn of
        READ ->
          [from, "world", readWorld] >>
          [into, "v_stack", cons]
      | WRITE ->
          [from, "v_stack", split1] >>
          [into, "world", writeWorld]
      | BINOP (op) ->
          [from, "v_stack", split2] >>
          [fmap, fun ([y, x]) { evalOp (op, x, y) }] >>
          [into, "v_stack", cons]
      | LD (l) ->
          [view, "state", [lookup, l]] >>
          [into, "v_stack", cons]
      | LDA (l) ->
          [on, "v_stack", cons (l)]
      | ST (l) ->
          [from, "v_stack", split1] >>= fun (v) {
          [just, "state", [assign, l, v]] }
      | STI ->
          [from, "v_stack", split2] >>= fun ([v, l]) {
          [just, "state", [assign, l, v]] >>
          [on, "v_stack", cons (v)] }
      | CONST (n) ->
          [on, "v_stack", cons (n)]
      | LABEL (_) ->
          id
      | JMP (l) ->
          [view, "subprogs", [fromLabel, l]] >>
          [into, "cont", const]
      | CJMP (Z, l) ->
          [from, "v_stack", split1] >>
          [fmap, fun (z) { z == 0 }] >>=
          [bool,
            [view, "subprogs", [fromLabel, l]] >>
            [into, "cont", const],
            id
          ]
      | CJMP (NZ, l) ->
          [from, "v_stack", split1] >>
          [fmap, fun (z) { z != 0 }] >>=
          [bool,
            [view, "subprogs", [fromLabel, l]] >>
            [into, "cont", const],
            id
          ]
      | CALL (l, _) ->
          [view, "state", getLocal] >>= fun ([args, locs]) {
          [view, "cont", id] >>= fun (cont) {
          [on, "c_stack", cons ([args, locs, cont])] >>
          [view, "subprogs", [fromLabel, l]] >>
          [into, "cont", const] } }
      | BEGIN (_, a, l) ->
          [createLocal, a, l] >>= fun ([args, locs]) {
          [on, "state", [setLocal, args, locs]] }
      | END ->
          [view, "c_stack", size] >>=
          [bool,
            [from, "c_stack", split1] >>= fun ([args, locs, cont]) {
            [on, "state", [setLocal, args, locs]] >>
            [on, "cont", const (cont)] },
            [on, "cont", const ({})]]
      | DUP ->
          [view, "v_stack", hd] >>
          [into, "v_stack", cons]
      | DROP ->
          [on, "v_stack", tl]
      esac
    )
  }

  -- Core interpreter: takes a configuration and a program, returns a configuration
  fun eval (env) {
    doM (env,
      [view, "cont", size] >>=
      [bool,
        [from, "cont", split1] >>
        [into, "all", evalInsn . ap] >>
        eval,
        id]
    )
  }

  case
    insns . splitWhileSome (
      fun (insn) {
        case insn of
          GLOBAL (name) -> Some (name)
        | _ -> None
        esac
      }) of [insns, glbs] ->
    case
      createData([
        "v_stack",  {},
        "c_stack",  {},
        "state",    makeState (0, 0, initArray (glbs.size, const (0)), glbs . enumerate),
        "world",    createWorld (input),
        "subprogs", initEvalEnv (insns),
        "cont",     insns]) of env ->
      gets (eval (env), "world", getOutput)
    esac
  esac
}

-- Compilation environment: generates labels
fun makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, functions) {
  -- Generates a new label
  fun genLabel () {
    [makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions), sprintf ("L%d", nLabels)]
  }

  -- Adds a new function
  fun rememberFun (fLabel, args, body) {
    makeCompEnv (nLabels,
                 scopeDepth,
                 state,
                 nLocals,
                 nArgs,
                 Fun (fLabel, args, body, state) : functions)
  }

  -- Enters a local scope
  fun beginScope () {
    makeCompEnv (nLabels, scopeDepth+1, enterScope (state), nLocals, nArgs, functions)
  }

  -- Leaves a local scope
  fun endScope () {
    makeCompEnv (nLabels, scopeDepth-1, leaveScope (state), nLocals, nArgs, functions)
  }

  -- Adds an argument for the current function
  fun addArg (name) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Arg (nArgs)), nLocals, nArgs+1, functions)
  }

  -- Adds a local variable for the current function
  fun addVar (name) {
    if scopeDepth == 1
    then makeCompEnv (nLabels, scopeDepth, addName (state, name, Glb (name)), nLocals, nArgs, functions)
    else makeCompEnv (nLabels, scopeDepth, addName (state, name, Loc (nLocals)), nLocals+1, nArgs, functions)
    fi
  }

  -- Adds a binding for a function
  fun addFun (name, fLabel, nargs) {
    makeCompEnv (nLabels, scopeDepth, addName (state, name, Fun (fLabel, nargs)), nLocals, nArgs, functions)
  }

  -- Enters a function
  fun beginFun (state) {
    makeCompEnv (nLabels, 1, enterFunction (state), 0, 0, functions)
  }

  -- Get functions and empty functions list
  fun getFuns () {
    [makeCompEnv (nLabels, scopeDepth, state, nLocals, nArgs, {}), functions]
  }

  -- Lookups a name of a variable
  fun lookupVar (name) {
    case lookup (state, name) of
      Fun (_, _) -> error (sprintf ("the name ""%s"" does not designate a variable", name), getLoc (name))
    | x          -> x
    esac
  }

  -- Lookups a name of a function
  fun lookupFun (name) {
    case lookup (state, name) of
      x@Fun (_, _) -> x
    | _            -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac
  }

  -- Gets the number of local variables
  fun getLocals () {
    nLocals
  }

  -- Generates an intrinsic function name
  fun genFunLabel (name) {
     if scopeDepth == 1
     then [makeCompEnv (nLabels  , scopeDepth, state, nLocals, nArgs, functions), bool (compare (name, "__main__") == 0, sprintf ("main"), sprintf ("L%s", name))]
     else [makeCompEnv (nLabels+1, scopeDepth, state, nLocals, nArgs, functions), sprintf ("L%s_%d", name, nLabels)]
     fi
  }

  -- Checks if the current scope is a global
  fun isGlobal () {
    scopeDepth == 1
  }

  [genLabel,
   rememberFun,
   beginScope,
   endScope,
   addArg,
   addVar,
   beginFun,
   getFuns,
   lookupVar,
   lookupFun,
   getLocals,
   genFunLabel,
   addFun,
   isGlobal
  ]
}

-- Initialize a new compilation environment
fun initCompEnv () {
  makeCompEnv (0, 0, emptyState (), 0, 0, {})
}

-- Accessor functions
fun genLabel (env) {
  env [0] ()
}

fun rememberFun (env, name, args, body) {
  env [1] (name, args, body)
}

fun beginScope (env) {
  env [2] ()
}

fun endScope (env) {
  env [3] ()
}

fun addArg (env, name) {
  env [4] (name)
}

fun addVar (env, name) {
  env [5] (name)
}

fun beginFun (env, state) {
  env [6] (state)
}

fun getFuns (env) {
  env [7] ()
}

fun lookupVar (env, name) {
  env [8] (name)
}

fun lookupFun (env, name) {
  env [9] (name)
}

fun getLocals (env) {
  env [10] ()
}

fun genFunLabel (env, name) {
  env [11] (name)
}

fun addFun (env, name, fLabel, nargs) {
  env [12] (name, fLabel, nargs)
}

fun isGlobal (env) {
  env [13] ()
}

-- Helper function: generates n labels
fun genLabels (env, n) {
  fun inner (env, n) {
    if n == 0
    then {env}
    else case genLabel (env) of
           [lab, env] -> lab : inner (env, n-1)
         esac
    fi
  }

  listArray (inner (env, n))
}

-- Helper function: adds a bunch of arguments
fun addArgs (env, names) {
  foldl (fun (env, name) {addArg (env, name)}, env, names)
}

-- Helper function: adds a bunch of locals
fun addVars (env, names) {
  foldl (fun (env, name) {addVar (env, name)}, env, names)
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.

-- Some guidelines for compiling functions and scopes.
--
-- 1. use env.beginScope/env.endScope properly;
-- 2. in each scope traverse the definitions twice:
--    a. first, add all bindings into symbolic state,
--       using end.addVar/env.addFun;
--    b. do not forget to generate GLOBAL instructions for
--       top-level variable declarations;
--    c. on the secord traversal add functions themselves for
--       future code generation (use env.rememberFun).
-- 3. the overall flow for code generation:
--    a. generate the code for the topmost expression (the program itself);
--    b. take list of nested functions definitions via env.getFuns and
--       generate the code for each function;
--    c. repeat b. until no function definitions appear.
-- 4. when compiling functions, do not forget to create proper
--    environment (use env.beginFun) and register arguments
--    (use env.addArg).

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  fun addCode (env, code) {
    doM (env,
      [on, "codeBuf", [bool (isSMInsn (code), infix <+, infix <+>), code]]
    )
  }

  fun genNewLabel (env) {
    doM (env,
      [from, "compEnv", genLabel] >>
      [fmap, [with, false]] >>
      [into, "labels", cons]
    )
  }

  fun getLastLabel (env) {
    doM (env,
      [on, ["labels","head","snd"], const (true)] >>
      [view, ["labels","head","fst"], id]
    )
  }

  fun setLastLabel (env) {
    doM (env,
      [from, "labels", split1] >>
      [into, "codeBuf", fun ([lbl, lblU]) { bool (lblU, [infix <+, LABEL (lbl)], id) }]
    )
  }

  fun withNewLabel (env, fdf) {
    doM (env,
      [from, "compEnv", genLabel] >>=
      fdf
    )
  }

  fun withLabel (env, lbl, df) {
    doM (env,
      [on, "labels", cons ([lbl, true])] >>
      df >>
      [on, "labels", tl]
    )
  }

  fun compile (env, expr) {
    doM (env,
      genNewLabel >>
      [genCode, expr] >>
      setLastLabel
    )
  }

  fun genCode (env, expr) {
    doM (env,
      case expr of
        Assn (r, v) ->
          [compile, r] >>
          [compile, v] >>
          [addCode, STI]
      | Seq (exp1, exp2) ->
          [compile, exp1] >>
          [genCode, exp2]
      | Skip ->
          id
      | Read (x) ->
          [addCode, READ] >>
          [view, "compEnv", [lookupVar, x]] >>= fun (v) {
          [addCode, ST (v)] }
      | Write (exp) ->
          [compile, exp] >>
          [addCode, WRITE]
      | If (cond, tbr, ebr) ->
          [withNewLabel, fun (lbl) {
            [compile, cond] >>
            [addCode, CJMP (Z, lbl)] >>
            [genCode, tbr] >>
            ((fun (lbl2) { [addCode, JMP (lbl2)] }) =<< getLastLabel) >>
            [addCode, LABEL (lbl)] >>
            [genCode, ebr]
          }]
      | While (cond, body) ->
          [withNewLabel, fun (lbl) {
            [addCode, LABEL (lbl)] >>
            [compile, cond] >>
            ((fun (lbl2) { [addCode, CJMP (Z, lbl2)] }) =<< getLastLabel) >>
            [withLabel, lbl, [genCode, body]] >>
            [addCode, JMP (lbl)]
          }]
      | DoWhile (body, cond) ->
          [withNewLabel, fun (lbl) {
            [addCode, LABEL (lbl)] >>
            [compile, body] >>
            [compile, cond] >>
            [addCode, CJMP (NZ, lbl)]
          }]
      | Var (x) ->
          [view, "compEnv", [lookupVar, x]] >>= fun (v) {
          [addCode, LD (v)] }
      | Ref (x) ->
          [view, "compEnv", [lookupVar, x]] >>= fun (r) {
          [addCode, LDA (r)] }
      | Const (num) ->
          [addCode, CONST (num)]
      | Binop (op, l, r) ->
          [compile, l] >>
          [compile, r] >>
          [addCode, BINOP (op)]
      | Scope (defs, exp) ->
          [from, "compEnv",
            beginScope >>
            traverse (
              fun (def) {
                case def of
                  Var (names) ->
                    [addVars, names] >>
                    [view, "all", isGlobal] >>=
                    [bool,
                      traverse (
                        fun (name) { [return, [addCode, GLOBAL (name)]] },
                        names),
                      [return, {}]]
                | Fun (name, args, body) ->
                    [genFunLabel, name] >>= fun (lbl) {
                    [addFun, name, lbl, args.size] >>
                    [return, {[on, "compEnv", [rememberFun, lbl, args, body]]}] }
                esac
              },
              defs)] >>
          [fmap, flatten] >>= fun (init) {
          foldl (infix >>, id, init) >>
          [compile, exp] >>
          [view, "compEnv", isGlobal] >>
          [into, "all", [bool,
            [addCode, END],
            id]] >>
          [from, "compEnv", getFuns] >>= fun (fs) {
          traverse_ (
            fun (Fun (lbl, args, body, state)) {
              [from, "codeBuf", fun (buf) { [emptyBuffer (), buf] }] >>= fun (savedCodeBuf) {
              [on, "compEnv", [beginFun, state]] >>
              [on, "compEnv", [addArgs, args]] >>
              [compile, body] >>
              [view, "compEnv", getLocals] >>= fun (locsAmt) {
              [from, "codeBuf", fun (buf) { [savedCodeBuf, buf] }] >>= fun (funCodeBuf) {
              [addCode, LABEL (lbl)] >>
              [addCode, BEGIN (lbl, args.size, locsAmt)] >>
              [addCode, funCodeBuf] >>
              [addCode, END]
              } } }
            },
            fs) >>
          [on, "compEnv",
            endScope
          ] } }
      | Call (name, exps) ->
          traverse_ (compile . ap, exps) >>
          [view, "compEnv", [lookupFun, name]] >>= fun (Fun (lbl, nargs)) {
          if nargs == exps.size
          then [addCode, CALL (lbl, nargs)]
          else const (error (sprintf ("amount of arguments of function %s mismatch (expected: %d, actual: %d)", name.string, nargs, exps.size), getLoc (name)))
          fi }
      | Ignore (exp) ->
          [compile, exp] >>
          [addCode, DROP]
      esac
    )
  }

  fun mainization (stmt) {
    case stmt of
      Scope (defs, expr) -> Scope (Fun ("__main__", {}, expr) : defs, Call ("__main__", {}))
    | _ -> Scope ({Fun ("__main__", {}, stmt)}, Call ("__main__", {}))
    esac
  }

  gets (
    compile (
      createData ([
        "compEnv", initCompEnv (),
        "labels", {},
        "codeBuf", emptyBuffer ()
      ]),
      mainization (stmt)),
    "codeBuf",
    getBuffer)
}
