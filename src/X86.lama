-- X86 codegeneration interface
-- We use stack machine programs as intermediate representation
import Fun;
import SM;
import Collection;
import List;
import Manifest;
import Buffer;
import Utils;

-- Assembler language interface
-- The registers: 
var regs = ["%ebx", "%ecx", "%esi", "%edi", "%eax", "%edx", "%ebp", "%esp"];

-- We can not freely operate with all register; only with 4 by now
var nRegs = regs.length - 5;

-- For convenience we define the following synonyms for the registers: 
var ebx = R (0),
    ecx = R (1),
    esi = R (2),
    edi = R (3),
    eax = R (4),
    edx = R (5),
    ebp = R (6),
    esp = R (7);

-- We need to know the word size to calculate offsets correctly
var wordSize = 4;

-- We need to distinguish the following operand types: 
--    R (int)       -- hard register                    
--    S (int)       -- a position on the hardware stack 
--    M (string)    -- a named memory location          
--    L (int)       -- an immediate operand
--    I (int, opnd) -- an indirect operand with offset

-- Some x86 instruction (we do not need all of them):
--   Mov   (opnd, opnd)         -- copies a value from the first to the second operand  
--   Lea   (opnd, opnd)         -- loads an address of the first operand into the second
--   Binop (string, opnd, opnd) -- makes a binary operation; note, the first operand   
--                                 designates x86 operator, not the source language one
--   IDiv  (opnd)               -- x86 integer division, see instruction set reference 
--   Cltd                       -- see instruction set reference           
--   Set   (string, string)     -- sets a value from flags; the first operand is the   
--                                 suffix, which determines the value being set, the
--                                 the second --- (sub)register name
--   Jmp   (string)             -- unconditional jump to a label
--   CJmp  (string, string)     -- conditional jump to a label
--   Label (string)             -- a label
--   Push  (opnd)               -- pushes the operand on the hardware stack
--   Pop   (opnd)               -- pops from the hardware stack to the operand
--   Call  (string)             -- calls a function by its name 
--   Ret                        -- returns from a function
--   Meta  (string)             -- metainformation (declarations, etc.)

-- Machine instruction printer
fun insnString (insn) {
  
  fun binopString (op) {
    case op of
      "+"   -> "addl"
    | "-"   -> "subl"
    | "*"   -> "imull"
    | "&&"  -> "andl"
    | "!!"  -> "orl" 
    | "^"   -> "xorl"
    | "cmp" -> "cmpl"
    esac
  }

  fun opndString (opnd) {
    case opnd of
      R (i)    -> regs [i]
    | S (i)    ->  if i >= 0
                   then sprintf ("-%d(%%ebp)", (i+1) * wordSize)
                   else sprintf ("%d(%%ebp)", 8 + (-1-i) * wordSize)
                   fi
    | M (x)    -> x
    | L (i)    -> sprintf ("$%d", i)
    | I (0, x) -> sprintf ("(%s)", opndString (x))
    | I (n, x) -> sprintf ("%d(%s)", n, opndString (x))
    esac
  }

  case insn of
    Cltd               -> "\tcltd\n"
  | Set   (c, s)       -> sprintf ("\tset%s\t%s\n", suffix (c), s)
  | IDiv  (s1)         -> sprintf ("\tidivl\t%s\n", opndString (s1))
  | Binop (op, s1, s2) -> sprintf ("\t%s\t%s,\t%s\n", binopString (op), opndString (s1), opndString (s2))
  | Lea   (s1, s2)     -> sprintf ("\tleal\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Mov   (s1, s2)     -> sprintf ("\tmovl\t%s,\t%s\n", opndString (s1), opndString (s2))
  | Push  (s)          -> sprintf ("\tpushl\t%s\n", opndString (s))
  | Pop   (s)          -> sprintf ("\tpopl\t%s\n", opndString (s))
  | Ret                -> "\tret\n"
  | Call  (p)          -> sprintf ("\tcall\t%s\n", p)
  | Label (l)          -> sprintf ("%s:\n", l)
  | Jmp   (l)          -> sprintf ("\tjmp\t%s\n", l)
  | CJmp  (c, l)       -> sprintf ("\tj%s\t%s\n", suffix (c), l)
  | Meta  (m)          -> m
  esac
}

fun isASMInsn (i) {
  case i of
    Cltd            -> true
  | Set   (_, _)    -> true
  | IDiv  (_)       -> true
  | Binop (_, _, _) -> true
  | Lea   (_, _)    -> true
  | Mov   (_, _)    -> true
  | Push  (_)       -> true
  | Pop   (_)       -> true
  | Ret             -> true
  | Call  (_)       -> true
  | Label (_)       -> true
  | Jmp   (_)       -> true
  | CJmp  (_, _)    -> true
  | Meta  (_)       -> true
  | _               -> false
  esac
}

-- Environment for symbolic interpreter
-- An environment holds
--    a symbolic stack
--    a maximal stack depth reached so far
--    a set of global variable names
--    a barrier condition (set up right after an unconditional jump is interpreter)
--    a stack map which maps labels to symbolic stacks

fun makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals) {
  -- Returns an internal name for a global variable
  fun globalName (name) {
    "global_" ++ name
  }

  -- Returns a string representation of the environment
  fun envString () {
    sprintf ("Stack     : %s\nStackSlots: %d\nGlobals   : %s\n", stack.string, stackSlots, elements (globals).string)
  }
  
  -- Allocates a new position on the symbolic stack;
  -- returns a pair: a location for allocated item and
  -- an updated environment
  fun allocate () {
    case 
      case stack of
        {}        -> [ebx, 0]
      | S (n) : _ -> [S (n+1), n+2]
      | R (n) : _ -> if n < nRegs then [R (n+1), stackSlots] else [S (nLocals), nLocals + 1] fi
      | _         -> [S (0), 1]
      esac
    of [x, n] -> [x, makeEnv (x : stack, if n > stackSlots then n else stackSlots fi, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)] esac
  }

  -- Pushes an item on the symbolic state; returns an updated envirtonment
  fun push (y) {
    makeEnv (y : stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  -- Pops one item from the symbolic stack; returns a pair: a popped
  -- item and an updated environment
  fun pop () {
    case stack of
      x : stack -> [x, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Pops two items from the symbolic stack; returns a triple:
  -- popped items and an undated environment
  fun pop2 () {
    case stack of
      x : y : stack -> [x, y, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Pops three items from the symbolic stack; returns a fouple:
  -- popped items and an undated environment
  fun pop3 () {
    case stack of
      x : y : z : stack -> [x, y, z, makeEnv (stack, stackSlots, globals, strings, stringIndex, barrier, stackMap, fLabel, nLocals)]
    esac
  }

  -- Peeks the top of the symbolic stack
  fun peek () {
    stack.fst
  }
  
  -- Adds a global variable; returns an updated environment
  fun addGlobal (name) {
    makeEnv (stack, stackSlots, addSet (globals, globalName (name)), strings, stringIndex, barrier, stackMap, fLabel, nLocals)
  }

  -- References an allocation
  fun loc (alloc) {
    case alloc of
      Glb (x) -> M (globalName (x))
    | Arg (i) -> S (-1-i)
    | Loc (i) -> S (i)
    esac
  }
  
  -- Gets a list of global variables from the environment
  fun getGlobals () {
    globals.elements
  }

  -- Gets a maximal stack size from the environment
  fun getStackSize () {
    stackSlots
  }

  -- Gets barrier condition
  fun isBarrier () {
    barrier
  }

  -- Sets barrier condition
  fun setBarrier () {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, true, stackMap, fLabel, nLocals)
  }

  -- Associates the current symbolic state with a label
  fun setStack (l) {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, addMap (stackMap, l, stack), fLabel, nLocals)
  }

  -- Retrieves a stack for a label
  fun retrieveStack (l) {
    case findMap (stackMap, l) of
      None         -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    | Some (stack) -> makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nLocals)
    esac
  }

  -- Sets the label of current function
  fun enterFunction (fLabel, nl) {
    makeEnv (stack, stackSlots, globals, strings, stringIndex, false, stackMap, fLabel, nl)
  }

  -- Gets the label of current function
  fun currentFunction () {
    fLabel
  }

  -- Gets the list of live registers past given symbolic stack depth
  fun liveRegisters (depth) {
    fun inner (d, acc, st) {
      case st of
        {}             -> acc
      | (r@R (_)) : tl -> inner (d+1, if d >= depth then r : acc else acc fi, tl)
      | _         : tl -> inner (d+1, acc, tl)
      esac
    }

    inner (0, {}, stack)
  }

  -- Registers a string literal and assigns it a name
  fun addString (s) {
    var escaped = makeString ((s.length + 1) * 2), i = 0, j = 0, name = sprintf ("string_%d", stringIndex);

    for skip, i < s.length, i := i+1 do
      case s[i] of
        '"'  -> escaped [j] :='"'; escaped [j+1] := '"'; j := j+2
      | '\n' -> escaped [j] :='\'; escaped [j+1] := 'n'; j := j+2
      | '\t' -> escaped [j] :='\'; escaped [j+1] := 't'; j := j+2
      | c    -> escaped [j] := c; j := j+1
      esac
    od;
    
    [makeEnv (stack, stackSlots, globals, addSet (strings, [name, substring (escaped, 0, j)]), stringIndex+1, false, stackMap, fLabel, nLocals), name]
  }

  -- Gets a list of all string literals and their names
  fun getStrings () {
    elements (strings)
  }

  -- Gets a local static size for the current function
  fun staticSize () {
    nLocals + stackSlots
  }

  [allocate,
   push,
   pop,
   pop2,
   pop3,
   addGlobal,
   loc,
   getGlobals,
   getStackSize,
   peek,
   isBarrier,
   setBarrier,
   setStack,
   retrieveStack,
   enterFunction,
   currentFunction,
   liveRegisters,
   addString,
   getStrings,
   staticSize]
}

-- Exported accessors
fun allocate () {
  [from, "env", fun (env) { env [0] () . swap }]
}

fun push (x) {
  [on, "env", fun (env) { env [1] (x) }]
}

fun popPure (env) {
  env [2] () . swap
}

fun pop () {
  [from, "env", popPure]
}

fun pop2 () {
  [from, "env", fun (env) { case env [3] () of [y, x, env] -> [env, [x, y]] esac }]
}

fun pop3 () {
  [from, "env", fun (env) { case env [4] () of [z, y, x, env] -> [env, [x, y, z]] esac }]
}

fun addGlobal (name) {
  [on, "env", fun (env) { env [5] (name) }]
}

fun loc (name) {
  [view, "env", fun (env) { env [6] (name) }]
}

fun getGlobalsPure (env) {
  env [7] ()
}

fun getStackSizePure (env) {
  env [8] ()
}

fun peek () {
  [view, "env", fun (env) { env [9] () }]
}

fun isBarrierPure (env) {
  env [10] ()
}

fun setBarrierPure (env) {
  env [11] ()
}

fun setStack (l) {
  [on, "env", fun (env) { env [12] (l) }]
}

fun retrieveStack (l) {
  [on, "env", fun (env) { env [13] (l) }]
}

fun enterFunction (fLabel, nL) {
  [on, "env", fun (env) { env [14] (fLabel, nL) }]
}

fun currentFunctionPure (env) {
  env [15] ()
}

fun liveRegisters (depth) {
  [view, "env", fun (env) { env [16] (depth) }]
}

fun addString (s) {
  [from, "env", fun (env) { env [17] (s) }]
}

fun getStringsPure (env) {
  env [18] ()
}

fun staticSizePure (env) {
  env [19] ()
}

-- Creates an initial environment
fun initEnv () {
  makeEnv ({}, 0, emptySet (compare), emptySet (compare), 0, false, emptyMap (compare), "", 0)
}

-- Codegeneration helper functions
-- Generates code section
fun codeSection (text) {
  singletonBuffer (Meta ("\t.text\n")) <+> text
}

-- Generates data section
fun dataSection (text) {
  singletonBuffer (Meta ("\t.data\n")) <+> text
}

-- Generates integer definition
fun intDef (name) {
  Meta (sprintf ("%s:\t.int\t0\n", name))
}

-- Generates string definition
fun stringDef ([name, vl]) {
  Meta (sprintf ("%s:\t.string\t""%s""\n", name, vl))
}

-- Generates function prologue
fun prologue (fLabel) {
  singletonBuffer (Push (ebp)) <+
  Mov   (esp, ebp) <+
  Binop ("-", M (sprintf ("$%s_SIZE", fLabel)), esp)  
}

-- Generates function epilogue
fun epilogue (env) {
  var metaDef = Meta (sprintf ("\t.set\t%s_SIZE,\t%d\n", env.currentFunctionPure, env.staticSizePure * wordSize));

  if compare (env.currentFunctionPure, "Main") == 0
  then [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Binop ("^", eax, eax) <+ Ret <+ metaDef]
  else case env.popPure of
         [env, y] -> [env, singletonBuffer (Mov (ebp, esp)) <+ Pop (ebp) <+ Mov (y, eax) <+ Ret <+ metaDef]
       esac
  fi
}

-- Checks if an operand resides on a stack
fun stackOpnd (opnd) {
  case opnd of
    S (_) -> true
  | _     -> false
  esac      
}

-- Checks if an operand resides in memory
fun memOpnd (opnd) {
  case opnd of
    S (_) -> true
  | M (_) -> true
  | _     -> false
  esac
}

-- Generates a move between locations, using
-- intermediate register if needed
fun move (from, to) {
  if from.compare(to) == 0
  then emptyBuffer ()
  else
    if memOpnd (from) && memOpnd (to)
    then singletonBuffer (Mov (from, eax)) <+ Mov (eax, to)
    else singletonBuffer (Mov (from, to))
    fi
  fi
}

-- Generates an operation with optional moving of arguments to %eax and %edx
-- (for operation which can't work with two arbitrary memory cells)
fun binop (op, l, r) {
  case (
    if memOpnd (l)
    then [fun (code) { move (l, edx) <+> code }, edx]
    else [id, l]
    fi) of [fCode, l2] ->
      case (
        if op.compare("*") == 0 && memOpnd (r)
        then [fun (code) { fCode (move (r, eax) <+> code <+> move (eax, r)) }, eax]
        else [fCode, r]
        fi) of [fCode, r2] ->
          Binop (op, l2, r2) . singletonBuffer . fCode
      esac
  esac
}

-- Gets a suffix for Set instruction from
-- source language comparison operator
fun suffix (op) {
  case op of
    "<"  -> "l"
  | "<=" -> "le"
  | "==" -> "e"
  | "!=" -> "ne"
  | ">=" -> "ge"
  | ">"  -> "g"
  esac
}

-- Gets a one-byte subregister of given four-byte register
fun set (op, R (i)) {
  Set (
    op,
    case regs[i] of
      "%ebx" -> "%bl"
    | "%ecx" -> "%cl"
    | "%eax" -> "%al"
    | "%edx" -> "%dl"
    esac
  ) . singletonBuffer
}

fun lea (v, r) {
  if memOpnd (r)
  then singletonBuffer (Lea (v, eax)) <+> move (eax, r)
  else singletonBuffer (Lea (v, r))
  fi
}

fun moveA (from, toA) {
  if stackOpnd (toA)
  then move (toA, eax) <+> move (from, I (0, eax))
  else move (from, I (0, toA))
  fi
}

-- Compiles stack machine code into a list of x86 instructions. Takes an environment
-- and stack machine code, returns an updated environment and x86 code.
fun compile (env, code) {
  fun addCode (insns) {
    [on, "code", traverse_ (fun (insn) { [bool (isASMInsn (insn), infix <+, infix <+>), insn] }, insns)]
  }

  fun compileOp (op, x, y, z) {
    case op of
      "+"  ->
        binop ("+", y, x) <+> move (x, z)
    | "-"  ->
        binop ("-", y, x) <+> move (x, z)
    | "*"  ->
        binop ("*", y, x) <+> move (x, z)
    | "/"  ->
        move (x, eax) <+ Cltd <+ IDiv (y) <+> move (eax, z)
    | "%"  ->
        move (x, eax) <+ Cltd <+ IDiv (y) <+> move (edx, z)
    | "==" ->
        move (L (0), eax) <+> binop ("cmp", y, x) <+> set ("==", eax) <+> move (eax, z)
    | "!=" ->
        move (L (0), eax) <+> binop ("cmp", y, x) <+> set ("!=", eax) <+> move (eax, z)
    | "<"  ->
        move (L (0), eax) <+> binop ("cmp", y, x) <+> set ("<",  eax) <+> move (eax, z)
    | "<=" ->
        move (L (0), eax) <+> binop ("cmp", y, x) <+> set ("<=", eax) <+> move (eax, z)
    | ">"  ->
        move (L (0), eax) <+> binop ("cmp", y, x) <+> set (">",  eax) <+> move (eax, z)
    | ">=" ->
        move (L (0), eax) <+> binop ("cmp", y, x) <+> set (">=", eax) <+> move (eax, z)
    | "&&" ->
        move (L (0), eax) <+> binop ("cmp", L (0), x) <+> set ("!=", eax) <+> move (L (0), edx) <+> binop ("cmp", L (0), y) <+> set ("!=", edx) <+> binop ("&&", edx, eax) <+> move (eax, z)
    | "!!" ->
        move (L (0), eax) <+> binop ("cmp", L (0), x) <+> set ("!=", eax) <+> move (L (0), edx) <+> binop ("cmp", L (0), y) <+> set ("!=", edx) <+> binop ("!!", edx, eax) <+> move (eax, z)
    esac
  }

  fun callFun (name, nargs, isEllipsis) {
    liveRegisters (nargs) >>= fun (lrs) {
    traverse_ (fun (lr) {
      addCode ({
        Push (lr) }) },
      lrs) >>
    replicateM_ (nargs,
      pop () >>= fun (a) {
      addCode ({
        Push (a) }) }) >>
    (if isEllipsis
     then addCode ({
            Push (L (nargs)) })
     else id
     fi ) >>
    addCode ({
      Call (name) }) >>
    (if isEllipsis
     then addCode ({
            Pop (edx) })
     else id
     fi ) >>
    replicateM_ (nargs,
      addCode ({
        Pop (edx) })) >>
    traverse_ (fun (lr) {
      addCode ({
        Pop (lr) }) },
      lrs.reverse) >>
    allocate () >>= fun (rr) {
    addCode ({
      move (eax, rr) }) } }
  }

  fun sexpTagToInt (tag) {
    fun charToInt (char) {
      if char == '_' then 1
      elif char >= 'A' && char <= 'Z' then char - 'A' + 2
      elif char >= 'a' && char <= 'z' then char - 'a' + 28
      else char - '0' + 54
      fi
    }

    fun maybeCharToInt (str_, idx) {
      if idx < str_.length
      then charToInt (str_ [idx])
      else 0
      fi
    }

    maybeCharToInt (tag, 0) +
    maybeCharToInt (tag, 1) * 64 +
    maybeCharToInt (tag, 2) * 4096 +
    maybeCharToInt (tag, 3) * 262144 +
    maybeCharToInt (tag, 4) * 16777216
  }

  fun compile (env, code) {
    foldl (
      fun (c, i) {
        doM (c,
          addCode ({ Meta ("#" ++ showSMInsn (i) ++ "\n") }) >>
          case i of
            BINOP (op) ->
              pop2 () >>= fun ([x, y]) {
              allocate () >>= fun (z) {
              addCode ({
                compileOp (op, x, y, z) }) } }
          | LD (x) ->
              allocate () >>= fun (s) {
              loc (x) >>= fun (l) {
              addCode ({
                move (l, s) }) } }
          | LDA (x) ->
              allocate () >>= fun (s) {
              loc (x) >>= fun (l) {
              addCode ({
                lea (l, s) }) } }
          | ST (x) ->
              pop () >>= fun (v) {
              loc (x) >>= fun (l) {
              addCode ({
                move (v, l) }) } }
          | STI ->
              pop2 () >>= fun ([xA, v]) {
              allocate () >>= fun (s) {
              addCode ({
                moveA (v, xA),
                move (v, s) }) } }
          | SEXP (tag, n) ->
              allocate () >>= fun (ts) {
              addCode ({
                move (L (sexpTagToInt (tag)), ts) }) >>
              callFun ("Bsexp", n + 1, true) }
          | CONST (n) ->
              allocate () >>= fun (s) {
              addCode ({
                move (L (n), s) }) }
          | LABEL (l) ->
              retrieveStack (l) >>
              addCode ({
                if l.compare("Main") == 0
                then Label ("main")
                else Label (l)
                fi })
          | JMP (l) ->
              setStack (l) >>
              addCode ({
                Jmp (l) })
          | CJMP (Z, l) ->
              pop () >>= fun (v) {
              setStack (l) >>
              addCode ({
                binop ("cmp", L (0), v),
                CJmp ("==", l) }) }
          | CJMP (NZ, l) ->
              pop () >>= fun (v) {
              setStack (l) >>
              addCode ({
                binop ("cmp", L (0), v),
                CJmp ("!=", l) }) }
          | CALL (f, n) ->
              case splitString (f) of
                ['M', _] ->
                  [on, "is_meta_main", const (true)]
              | ['E', name] ->
                  callFun ("L" ++ name, n, false)
              | ['L', name] ->
                  callFun ("L" ++ name, n, false)
              esac
          | BEGIN (f, a, l) ->
              enterFunction (f, l) >>
              addCode ({
                prologue (f) })
          | GLOBAL (x) ->
              addGlobal (x)
          | END ->
              [from, "is_meta_main", fun (imm) { [false, imm] }] >>=
              [bool,
                id,
                [from, "env", epilogue] >>= fun (epilogueCode) {
                addCode ({
                  epilogueCode }) }]
          | DUP ->
              peek () >>= fun (v) {
              allocate () >>= fun (s) {
              addCode ({
                move (v, s) }) } }
          | DROP ->
              pop ().void
          | STRING (s) ->
              addString (s) >>= fun (sn) {
              allocate () >>= fun (ss) {
              addCode ({
                lea (M (sn), ss) }) >>
              callFun ("Bstring", 1, false) } }
          | ARRAY (n) ->
              callFun ("Barray", n, true)
          | STA ->
              callFun ("Bsta", 3, false)
          | ELEM ->
              callFun ("Belem", 2, false)
          esac
        )
      },
      createData ([
        "env", env,
        "code", emptyBuffer (),
        "is_meta_main", true]),
      code)
  }

  gets (compile (env, code), "raw", id)
}

-- A top-level codegeneration function. Takes a driver's environment and a stack machine program,
-- compiles the program into machine code, and compiles the machine code into an executable
public fun compileX86 (args, code) {
  case compile (initEnv (), code) of
    [env, code, _] ->
       var asmFile = args.getBaseName ++ ".s",
           runtime = case getEnv ("LAMA_RUNTIME") of
                       #val -> "../runtime/"
                     | path -> path
                     esac ++ "/runtime.o";

       fwrite (asmFile,
               map (insnString, 
                    getBuffer $
                      singletonBuffer (Meta ("\t.global\tmain\n")) <+>
                      dataSection (listBuffer (map (intDef   , getGlobalsPure (env))) <+>
                                   listBuffer (map (stringDef, getStringsPure (env)))) <+>
                      codeSection (code)
                   ).stringcat);
                    
       system ({"gcc -g -m32 -o ", args.getBaseName, " ", runtime, " ", asmFile}.stringcat)
  esac
}
