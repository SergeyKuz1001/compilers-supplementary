-- Expression evaluator

import List;
import Array;
import Collection;
import State;
import World;
import Lexer;
import Parser;
import Fun;
import Utils;
import Builtins;
import Memory;

-- As association map which maps "\otimes" into "\oplus"
var ops = {
  ["+" , infix + ],
  ["-" , infix - ],
  ["*" , infix * ],
  ["/" , infix / ],
  ["%" , infix % ],
  ["==", infix ==],
  ["!=", infix !=],
  ["<" , infix < ],
  ["<=", infix <=],
  [">" , infix > ],
  [">=", infix >=],
  ["&&", infix &&],
  ["!!", infix !!]
};

-- The evaluator for infix operators: takes an operator as a string
-- and two operand values, and returns the result
public fun evalOp (op, l, r) {
  case assoc (ops, op) of
    Some (f) -> f (l, r)
  esac
}

-- Evaluates an expression "expr" in a configuration "c".
-- A configuration is a pair of a state "s" and a world "w".
-- Returns a final configuration (if any)
--
-- A expression is represented by a data structure of the following shape:
--
-- expr = Assn    (expr, expr)         |
--        Set     (string, expr)       |
--        Seq     (expr, expr)         |
--        Skip                         |
--        If      (expr, expr, expr)   |
--        While   (expr, expr)         |
--        DoWhile (expr, expr)         |
--        Var     (string)             |
--        Ref     (string)             |
--        Const   (int)                |
--        Binop   (string, expr, expr) |
--        Scope   (def list, expr)     |
--        Call    (string, expr list)  |
--        Ignore  (expr)               |
--        String  (string)             |
--        Array   (expr list)          |
--        Sexp    (string, expr list)  |
--        Elem    (expr, expr)         |
--        ElemRef (expr, expr)
--
-- def = Var (string list)               |
--       Val (string list)               |
--       Fun (string, string list, expr)

-- Evaluates a list of expressions, properly threading a configurations.
-- Returns the final configuration and the list of values

fun eval (c, expr) {
  fun gcCheckAndRun () {
    gcCheckMemory () >>= fun (okMemory) {
    if okMemory
    then id
    else getAllValues () >>= fun (scopesLocs) {
         gcRun (scopesLocs) >>
         gcUpdateBorder (fun (border) { border + 10 })}
    fi }
  }

  doM (c,
    gcCheckAndRun () >>
    case expr of
      Assn (r, v) ->
        traverse (eval.ap, {r, v}) >>= fun ({rl, vv}) {
        set (rl, vv) >>
        return (vv) }
    | Set (x, v) ->
        [eval, v] >>= fun (vv) {
        allocate (vv) >>= fun (vl) {
        (x <- vl) >>
        return (vv) } }
    | Seq (exp1, exp2) ->
        [eval, exp1].void >>
        [eval, exp2]
    | Skip ->
        return (0)
    | If (cond, tbr, ebr) ->
        [eval, cond] >>= fun (v) {
        if v != 0
        then [eval, tbr]
        else [eval, ebr]
        fi }
    | While (cond, body) ->
        [eval, cond] >>= fun (v) {
        if v != 0
        then [eval, body].void >>
             [eval, expr]
        else return (0)
        fi }
    | DoWhile (body, cond) ->
        [eval, body].void >>
        [eval, cond] >>= fun (v) {
        if v != 0
        then [eval, expr]
        else return (0)
        fi }
    | Var (name) ->
        lookupVal (name) >>= fun (l) {
        get (l) }
    | Ref (name) ->
        lookupVar (name)
    | Const (num) ->
        return (num)
    | Binop (op, l, r) ->
        traverse (eval.ap, {l, r}) >>= fun ({lv, rv}) {
        return (evalOp (op, lv, rv)) }
    | Scope (defs, exp) ->
        enterScope () >>
        traverse_ (
          fun (def) {
            case def of
              Var (names) ->
                replicateM (names.size, allocate ()) >>= fun (locs) {
                addVars (zip (names, locs)) }
            | Val (names) ->
                addVals (zip (names, replicate (names.size, -1)))
            | Fun (n, as, b) ->
                addFun (n, as, b)
            esac
          },
          defs) >>
        [eval, exp] >>
        leaveScope ()
    | Call (name, exps) ->
        lookupFun (name) >>= fun ([args, body]) {
        traverse (eval.ap, exps) >>= fun (params) {
        case body of
          External ->
            traverse (getDeep, params) >>= fun (params_) {
            evalBuiltin (name, params_) }
        | _ ->
            getState () >>= fun (savedState) {
            enterFunction () >>
            traverse (allocate, params) >>= fun (paramLocs) {
            addVals (zip (args, paramLocs)) >>
            getAllValues () >>= fun (avs) {
            [eval, body] >>= fun (res) {
            getGlobal () >>= fun (glbl) {
            setState (savedState) >>
            leaveFunction (glbl) >>
            return (res) } } } } }
        esac
        } }
    | Ignore (exp) ->
        [eval, exp].void >>
        return (0)
    | String (s) ->
        traverse (allocate, init (s.length, fun (i) { s [i] })) >>
        [fmap, createArray]
    | Array (exps) ->
        traverse (fun (exp) { [eval, exp] >>= allocate }, exps) >>
        [fmap, createArray]
    | Sexp (name, exps) ->
        traverse (fun (exp) { [eval, exp] >>= allocate }, exps) >>
        [fmap, fun (elemLocs) { createSexp (name, elemLocs) }]
    | Elem (arr, idx) ->
        traverse (eval.ap, {arr, idx}) >>= fun ({a, i}) {
        getElemLoc (a, i) >>=
        get }
    | ElemRef (arr, idx) ->
        traverse (eval.ap, {arr, idx}) >>= fun ({a, i}) {
        getElemLoc (a, i) }
    esac
  )
}

-- Evaluates a program with a given input and returns an output
public fun evalExpr (input, expr) {
  getOutput (
    eval (
      createData ([
        "state", emptyState ().enterScopePure
                              .addNamePure ("read",   Fun ({}, External))
                              .addNamePure ("write",  Fun ({"a"}, External))
                              .addNamePure ("length", Fun ({"a"}, External)),
        "memory", emptyMemory (50),
        "world", createWorld (input)]),
      expr))
}
