-- States: partial maps from variables into values

import Collection;
import List;
import Lexer;
import Parser;
import Fun;
import Utils;

-- State with a stack of scopes; each scope is a map from names to
-- their kind and values
fun makeState (scopes) {
  -- Searches a scope stack and performed a speficified action
  -- on the found binding
  fun lookup (name) {
    fun lookupInScopes (scopes) {
      case scopes of
        {}         -> error (sprintf ("name ""%s"" is undefined", name), getLoc (name))
      | s : scopes ->
         case findMap (s, name) of
           None     -> lookupInScopes (scopes)
         | Some (x) -> x
         esac
      esac
    }

    lookupInScopes (scopes)  
  }
  
  -- Makes and assignment in scopes
  fun assign (name, vl) {
    fun assignInScopes (scopes) {
      case scopes of
        {}         -> error (sprintf ("name ""%s"" is undefined", name), getLoc (name))
      | s : scopes ->
         case findMap (s, name) of
           None           -> s : assignInScopes (scopes)
         | Some (Val (_)) -> addMap (s, name, Val (vl)) : scopes
         | Some (Var (_)) -> addMap (s, name, Var (vl)) : scopes
         esac
      esac
    }

    makeState (assignInScopes (scopes))
  }

  -- Enters a new scope
  fun enterScope () {
    makeState (emptyMap (compare) : scopes)
  }

  -- Leaves a scope
  fun leaveScope () {
    makeState (scopes.tl)
  }

  -- Adds a name into a scope
  fun addName (name, vl) {
    case scopes of
      s : scopes ->
       case findMap (s, name) of
         None     -> makeState (addMap (s, name, vl) : scopes)
       | Some (_) -> error (sprintf ("duplicate ""%s"" name definition", name), getLoc (name))
       esac
    esac
  }

  -- Enters a function; this drops all local scopes and creates a new one
  fun enterFunction () {
    fun enterScopes (scopes) {
      case scopes of        
        {_, _}     -> scopes
      | _ : scopes -> enterScopes (scopes)
      esac
    }

    var valuesScope = listMap (map (fun ([x, i]) { [sprintf ("*%d", i), Val (x)] }, enumerate (elements (listSet (getAllValues (), compare)))), compare);

    makeState (emptyMap (compare) : valuesScope : enterScopes (scopes))
  }

  -- Leaves a function: replaces the global scope in the state with a given one
  fun leaveFunction (global) {
    fun replaceGlobal (scopes) {
      case scopes of
        {_, _}     -> global
      | s : scopes -> s : replaceGlobal (scopes)
      esac    
    }

    makeState (replaceGlobal (scopes))
  }

  -- Gets a global scope from a state
  fun getGlobal () {
    fun findGlobal (scopes) {
      case scopes of
        {_, _}     -> scopes
      | _ : scopes -> findGlobal (scopes)
      esac
    }

    findGlobal (scopes)
  }

  fun getAllValues () {
    foldl (
      fun (acc, scope) {
        foldl (fun (acc, [_, value]) {
          case value of
            Val (v) -> v : acc
          | Var (v) -> v : acc
          | _       -> acc
          esac
        }, acc, bindings (scope))
      },
      {},
      scopes)
  }

  [lookup, assign, enterScope, leaveScope, addName, enterFunction, leaveFunction, getGlobal, getAllValues]
}

-- Accessors functions
public fun lookupPure (state, x) {
  state [0] (x)
}

public fun lookup (x) {
  [view, "state", [lookupPure, x]]
}

public infix <- before : (x, v) {
  [on, "state", fun (state) { state [1] (x, v) }]
}

public fun enterScopePure (state) {
  state [2] ()
}

public fun enterScope () {
  [on, "state", enterScopePure]
}

public fun leaveScopePure (state) {
  state [3] ()
}

public fun leaveScope () {
  [on, "state", leaveScopePure]
}

public fun addNamePure (state, name, vl) {
  state [4] (name, vl)
}

public fun addName (name, vl) {
  [on, "state", [addNamePure, name, vl]]
}

public fun enterFunctionPure (state) {
  state [5] ()
}

public fun enterFunction () {
  [on, "state", enterFunctionPure]
}

public fun leaveFunctionPure (state, global) {
  state [6] (global)
}

public fun leaveFunction (global) {
  [on, "state", [leaveFunctionPure, global]]
}

public fun getGlobal () {
  [view, "state", fun (state) { state [7] () }]
}

public fun getAllValues () {
  [view, "state", fun (state) { state [8] () }]
}

-- Creates an empty state
public fun emptyState () {
  makeState ({})
}

-- Helper function: checks that given name designates a regular variable in
-- a given state
public fun lookupVar (name) {
  lookup (name) >>= fun (found) {
  return (
    case found of
      Var (value) -> value
    | _           -> error (sprintf ("the name ""%s"" does not designate a mutable variable", name), getLoc (name))
    esac) }
}

-- Helper function: checks that given name designates a regular variable in
-- a given state
public fun lookupVal (name) {
  lookup (name) >>= fun (found) {
  return (
    case found of
      Var (value) -> value
    | Val (value) -> value
    | q           -> error (sprintf ("the name ""%s"" does not designate a immutable variable (%s)", name, q.string), getLoc (name))
    esac) }
}

-- Helper function: checks that given name designates a function in
-- a given state
public fun lookupFun (name) {
  lookup (name) >>= fun (found) {
  return (
    case found of
      Fun (args, body) -> [args, body]
    | _                -> error (sprintf ("the name ""%s"" does not designate a function", name), getLoc (name))
    esac) }
}

-- Helper function: adds a bunch of regular variables current scope
public fun addVars (vars) {
  traverse_ (
    fun ([name, value]) {
      addName (name, Var (value))
    },
    vars)
}

-- Helper function: adds a bunch of regular variables current scope
public fun addVals (vals) {
  traverse_ (
    fun ([name, value]) {
      addName (name, Val (value))
    },
    vals)
}

-- Helper function: adds a function in current scope
public fun addFun (name, args, body) {
  addName (name, Fun (args, body))
}

public fun getState () {
  [view, "state", id]
}

public fun setState (state) {
  [on, "state", const (state)]
}
