-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inbrP (p) {
  inbr (s ("("), p, s (")"))
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbrP[exp]),
    exp = memo $ eta (expr ({[Left,  {[s ("!!"), fun (l, _, r) { Binop ("!!", l, r) }]}],
                             [Left,  {[s ("&&"), fun (l, _, r) { Binop ("&&", l, r) }]}],
                             [Nona,  {[s ("=="), fun (l, _, r) { Binop ("==", l, r) }],
                                      [s ("!="), fun (l, _, r) { Binop ("!=", l, r) }],
                                      [s ("<="), fun (l, _, r) { Binop ("<=", l, r) }],
                                      [s ("<"),  fun (l, _, r) { Binop ("<",  l, r) }],
                                      [s (">="), fun (l, _, r) { Binop (">=", l, r) }],
                                      [s (">"),  fun (l, _, r) { Binop (">",  l, r) }]}],
                             [Left,  {[s ("+"),  fun (l, _, r) { Binop ("+",  l, r) }],
                                      [s ("-"),  fun (l, _, r) { Binop ("-",  l, r) }]}],
                             [Left,  {[s ("*"),  fun (l, _, r) { Binop ("*",  l, r) }],
                                      [s ("/"),  fun (l, _, r) { Binop ("/",  l, r) }],
                                      [s ("%"),  fun (l, _, r) { Binop ("%",  l, r) }]}]}, primary)),
    baseStmt = memo $ eta syntax (l=lident -s[":="] r=exp { Assn (l, r) } |
                                  -kRead v=inbrP[lident] { Read (v) } |
                                  -kWrite e=inbrP[exp] { Write (e) }),
    stmt = memo $ eta (expr ({[Right, {[s (";"), fun (l, _, r) { Seq (l, r) }]}]}, baseStmt));
   

-- Public top-level parser
public parse = stmt;
             
