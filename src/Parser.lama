-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
public fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- Global AST environment
var envId = 0;

fun freshName () {
  envId := envId + 1;
  sprintf ("_tmp%d", envId)
}

-- Attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")
--   Weak --- works like Val, but allows to provide a "default" value for void constructs

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, vl, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (vl)
  | _    -> vl
  esac
}

-- Checks if a void epxression can be used in the context described by
-- the attribute "atr".
fun assertVoid (atr, vl, loc) {
  case atr of
    Void -> vl
  | Val  -> error ("value expected", loc)
  | Weak -> Seq (vl, Const (0))
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inbrP (p) {
  inbr (s ("("), p, s (")"))
}

fun inbrC (p) {
  inbr (s ("{"), p, s ("}"))
}

fun inbrB (p) {
  inbr (s ("["), p, s ("]"))
}

-- A helper function to be used with super-combinator "expr"
fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

-- Helper parser: parses a (possible empty) list of items separated by ","
fun list0 (item) {
  list0By (item, s(","))
}

-- Helper parser: parses a non-empty list of items separated by ","
fun list (item) {
  listBy (item, s(","))
}

-- Helper AST function: expands a "raw" scope expression, reifying
-- initializers into assignments
fun expandScope (defs, expr) {
  fun expandVarDefs (defs, expr) {
    foldr (fun ([defs, expr], def) {     
             case def of
                [ident, None]         -> [ident : defs, expr]
             |  [ident, Some (value)] -> [ident : defs, Seq (Ignore (Assn (Ref (ident), value)), expr)]
             esac
           },
           [{}, expr],
           defs)
  }

  fun expandValDefs (defs, expr) {
    foldr (fun ([defs, expr], [ident, value]) {     
             [ident : defs, Seq (Ignore (Set (ident, value)), expr)]
           },
           [{}, expr],
           defs)
  }

  case 
    foldr (fun ([defs, expr], def) {
             case def of
               f@Fun (_, _, _) -> [f : defs, expr]
             | Val (ds) ->
                 case expandValDefs (ds, expr) of
                   [ds, expr] -> [Val (ds) : defs, expr]
                 esac
             | Var (ds) ->             
                 case expandVarDefs (ds, expr) of
                   [ds, expr] -> [Var (ds) : defs, expr]
                 esac
             esac
           },
           [{}, expr],
           defs) of
    [defs, expr] -> Scope (defs, expr)
  esac
}

-- Helper AST function: distributes a scope through an expression
fun distributeScope (expr, exprConstructor) {
  case expr of
    Scope (defs, sexpr) -> Scope (defs, exprConstructor (sexpr))
  | _                   -> exprConstructor (expr)
  esac
}

-- Helper AST function: reifies pattern bindings into scope
-- definitions and assignments; takes an returns lists of
-- pattern-branch pairs
fun reifyPatternBindings (matched, brs) {
  fun collectBindings (path, p) {
    fun collectList (path, ps) {
      case
        foldl (fun ([acc, i], p) {
                 [collectBindings (i : path, p) : acc, i+1]
               },
               [{}, 0],
               ps) of
        [acc, _] -> flatten (acc)
      esac
    }

    case p of
      Sexp  (_, ps)   -> collectList (path, ps)
    | Array (ps)      -> collectList (path, ps)
    | Named (name, p) -> [name, path] : collectBindings (path, p)
    |  _              -> {}
    esac
  }

  map (
    fun ([pat, br]) {
      case collectBindings ({}, pat) of
        {}       -> [pat, br]
      | bindings -> [pat,
          expandScope (
            { Val (map (
                     fun ([name, path]) {
                       [name, foldr (fun (p, i) { Elem (p, Const (i)) }, Var (matched), path)]
                     }, bindings)) },
            br)]
      esac
    },
    brs
  )
}

fun createFun (name, args, body) {
  fun isPure (exp) {
    case exp of
      Const (_) -> true
    | Var (name) -> case find (fun (arg) { compare (name, arg) == 0 }, args) of None -> false | Some (_) -> true esac
    | Binop (_, l, r) -> isPure (l) && isPure (r)
    | If (c, t, e) -> isPure (c) && isPure (t) && isPure (e)
    | Call (fName, args) -> foldl (fun (acc, arg) { acc && isPure (arg) }, compare (fName, name) == 0, args)
    | _ -> false
    esac
  }

  Fun (name, args, if isPure (body) then Pure (body) else Impure (body) fi)
}
 
var primary    = memo $ eta syntax (
      -- array constant
      loc=pos x=inbrB[list0(syntax (e=exp { e (Val) }))]
                              { fun (a) { assertValue (a, Array (x), loc) } } |

      -- string constant
      loc=pos x=strlit        { fun (a) { assertValue (a, String (x), loc) } } |

      -- character literal
      loc=pos x=chrlit        { fun (a) { assertValue (a, Const (x), loc) } } |

      -- decimal constant
      loc=pos x=decimal       { fun (a) { assertValue (a, Const (stringInt (x)), loc) } } |

      -- identifier
      loc=pos x=lident args=inbrP[list0(syntax(e=exp { e (Val) }))]?
                              { fun (a) {
                                  case args of
                                    None -> case a of
                                              Ref  -> Ref (x)
                                            | Void -> Ignore (Var (x))
                                            | _    -> Var (x)
                                            esac
                                  | Some (args) -> assertValue (a, Call (x, args), loc)
                                  esac
                                } } |

      -- S-expression
      loc=pos x=uident args=inbrP[list0(syntax(e=exp { e (Val) }))]?
                              { fun (a) { assertValue (a, Sexp (x,
                                  case args of
                                    None        -> {}
                                  | Some (args) -> args
                                  esac), loc)
                                } } |

      loc=pos -kSkip          { fun (a) {
                                  assertVoid (a, Skip, loc)
                                } } |

      loc=pos -kIf c=exp
              -kThen tb=scopeExpr
              eicbs=(memo [eta syntax (-kElif c=exp -kThen b=scopeExpr { [c, b] })])*
              ebm=(-kElse scopeExpr)?
              -kFi            { fun (a) {
                                  foldr (
                                    fun (acc, [c, b]) { If (c (Val), b (a), acc) },
                                    case ebm of
                                      Some (eb) -> eb (a)
                                    | None -> assertVoid (a, Skip, loc)
                                    esac,
                                    [c, tb] : eicbs)
                                } } |

      loc=pos -kWhile c=exp
              -kDo b=scopeExpr
              -kOd            { fun (a) {
                                  assertVoid (a, While (c (Val), b (Void)), loc)
                                } } |

      loc=pos -kDo b=scopeExpr
              -kWhile c=exp
              -kOd            { fun (a) {
                                  assertVoid (a,
                                    distributeScope (
                                      b (Void),
                                      fun (bs) { DoWhile (bs, c (Val)) }
                                    ),
                                    loc)
                                } } |

      loc=pos -kFor
                i=scopeExpr -s[","]
                c=basic -s[","]
                n=basic
              -kDo b=scopeExpr
              -kOd            { fun (a) {
                                  assertVoid (a,
                                    distributeScope (
                                      i (Void),
                                      fun (is) { Seq (is, While (c (Val), Seq (b (Void), n (Void)))) }
                                    ),
                                    loc)
                                } } |

      loc=pos -kCase sc=exp -kOf
                brs=listBy[syntax (p=pattern s["->"] e=scopeExpr { [p, e] }), s("|")]
              -kEsac          { fun (a) {
                                  case freshName () of newName ->
                                  expandScope (
                                    {Val ({[newName, sc (Val)]})},
                                    foldr (
                                      fun (acc, [p, e]) { Match (newName, p, e, acc) },
                                      Fail (newName, loc),
                                      reifyPatternBindings (
                                        newName,
                                        map (
                                          fun ([p, e]) { [p, e (a)] },
                                          brs))))
                                  esac
                                } } |

      se=inbrP[scopeExpr]     { se }),

    pattern    = memo $ eta syntax (
      x=decimal               { Number (x.stringInt) } |

      s["_"]                  { Wildcard } |

      x=inbrB[list0(pattern)] { Array (x) } |

      n=uident x=inbrP[list0(pattern)]?
                              { Sexp  (n, case x of
                                            None -> {}
                                          | Some (args) -> args
                                          esac) } |

      n=lident p=(-s["@"] pattern)?
                              { Named (n, case p of
                                            None -> Wildcard
                                          | Some (p) -> p
                                          esac) }),

    basic      = memo $ eta (expr ({[Right, {[s (":="),
                                                fun (l, loc, r) {
                                                  fun (a) { assertValue (a, Assn (l (Ref), r (Val)), loc) }
                                                }]}],
                                      [Left,  map (binop, {"!!"})],
                                      [Left,  map (binop, {"&&"})],
                                      [Nona,  map (binop, {"==", "!=", "<", ">", "<=", ">="})],
                                      [Left,  map (binop, {"+", "-"})],
                                      [Left,  map (binop, {"*", "/", "%"})]
                                     },
                                     postfix)),

    postfix    = memo $ eta syntax (
      loc=pos e=primary ps=(i=inbrB[exp] { i (Val) })*
                              { fun (a) {
                                  foldl (
                                    fun (e, i) {
                                      fun (a) {
                                        case a of
                                          Ref -> ElemRef (e (Val), i)
                                        | _   -> assertValue (a, Elem (e (Val), i), loc)
                                        esac
                                      }
                                    }, e, ps) (a)
                                } }),

    scopeExpr  = memo $ eta syntax (
      ds=definition* e=exp?   { fun (a) {
                                  fun (e) {
                                    case ds of
                                      {} -> e
                                    | _  -> expandScope (ds, e) 
                                    esac
                                  } (case e of 
                                       Some (e) -> e (a)
                                     | _        -> Skip
                                     esac)
                                } }),

    definition = memo $ eta syntax (
      kVar ds=list[syntax (lident (s["="] e=basic { e (Val) })?)] s[";"]
                              { Var (ds) } |
      kVal ds=list[syntax (lident (s["="] e=basic { e (Val) }) )] s[";"]
                              { Val (ds) } |
      kFun name=lident
           args=inbrP[list0 (lident)]
           body=inbrC[scopeExpr]
                              { createFun (name, args, body (Weak)) }),

    exp        = memo $ eta syntax (
      s1=basic s2=(-s[";"] exp)?
                              { fun (a) {
                                  case s2 of
                                    None -> s1 (a)
                                  | Some (s2) -> Seq (s1 (Void), s2 (a))
                                  esac
                                } });

-- Public top-level parser
public parse = syntax (s=scopeExpr {s (Void)});
