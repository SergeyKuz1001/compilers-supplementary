-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inbrP (p) {
  inbr (s ("("), p, s (")"))
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbrP[exp]),
    exp = memo $ eta (expr ({[Left,  {[s ("!!"), fun (l, _, r) { Binop ("!!", l, r) }]}],
                             [Left,  {[s ("&&"), fun (l, _, r) { Binop ("&&", l, r) }]}],
                             [Nona,  {[s ("=="), fun (l, _, r) { Binop ("==", l, r) }],
                                      [s ("!="), fun (l, _, r) { Binop ("!=", l, r) }],
                                      [s ("<="), fun (l, _, r) { Binop ("<=", l, r) }],
                                      [s ("<"),  fun (l, _, r) { Binop ("<",  l, r) }],
                                      [s (">="), fun (l, _, r) { Binop (">=", l, r) }],
                                      [s (">"),  fun (l, _, r) { Binop (">",  l, r) }]}],
                             [Left,  {[s ("+"),  fun (l, _, r) { Binop ("+",  l, r) }],
                                      [s ("-"),  fun (l, _, r) { Binop ("-",  l, r) }]}],
                             [Left,  {[s ("*"),  fun (l, _, r) { Binop ("*",  l, r) }],
                                      [s ("/"),  fun (l, _, r) { Binop ("/",  l, r) }],
                                      [s ("%"),  fun (l, _, r) { Binop ("%",  l, r) }]}]}, primary)),
    baseStmt = memo $ eta syntax (l=lident -s[":="] r=exp { Assn (l, r) } |
                                  -kRead v=inbrP[lident] { Read (v) } |
                                  -kWrite e=inbrP[exp] { Write (e) } |
                                  -kSkip { Skip } |
                                  -kIf c=exp
                                    -kThen tb=stmt
                                    eicbs=(memo [eta syntax (-kElif c=exp -kThen b=stmt { [c, b] })])*
                                    ebm=(-kElse stmt)?
                                    -kFi { foldr (
                                      fun (acc, [c, b]) { If (c, b, acc) },
                                      ebm . fromMaybe (Skip),
                                      [c, tb] : eicbs) } |
                                  -kWhile c=exp -kDo b=stmt -kOd { While (c, b) } |
                                  -kDo b=stmt -kWhile c=exp -kOd { DoWhile (b, c) } |
                                  -kFor i=stmt -s[","] c=exp -s[","] n=stmt -kDo b=stmt -kOd {
                                    Seq (i, While (c, Seq (b, n))) }),
    stmt = memo $ eta (expr ({[Right, {[s (";"), fun (l, _, r) { Seq (l, r) }]}]}, baseStmt));

fun fromMaybe (mValue, default) {
  case mValue of
    Some (value) -> value
  | None -> default
  esac
}

-- Public top-level parser
public parse = stmt;
