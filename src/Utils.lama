-- Helpful functions

public fun onFst (arr, df) {
  case arr of
    [x, y]    -> case dot (df, x) of x -> [x, y]    esac
  | [x, y, z] -> case dot (df, x) of x -> [x, y, z] esac
  esac
}

public fun fromFst (arr, df) {
  case arr of
    [x, y]    -> case dot (df, x) of [x, v] -> [[x, y],    v] esac
  | [x, y, z] -> case dot (df, x) of [x, v] -> [[x, y, z], v] esac
  esac
}

public fun intoFst ([arr, v], fdf) {
  case arr of
    [x, y] ->    case fdf (v) of df -> case dot (df, x) of x -> [x, y]    esac esac
  | [x, y, z] -> case fdf (v) of df -> case dot (df, x) of x -> [x, y, z] esac esac
  esac
}

public fun overFst ([arr, v], fdf) {
  case arr of
    [x, y]    -> case fdf (v) of [df, v] -> case dot (df, x) of x -> [[x, y], v]    esac esac
  | [x, y, z] -> case fdf (v) of [df, v] -> case dot (df, x) of x -> [[x, y, z], v] esac esac
  esac
}

public fun acrossFst ([arr, v], fdf) {
  case arr of
    [x, y]    -> case fdf (v) of df -> case dot (df, x) of [x, v] -> [[x, y], v]    esac esac
  | [x, y, z] -> case fdf (v) of df -> case dot (df, x) of [x, v] -> [[x, y, z], v] esac esac
  esac
}

public fun underFst ([arr, v], fdf) {
  case arr of
    [x, y]    -> case fdf (v) of df -> case dot (df, x) of x -> [[x, y], v]    esac esac
  | [x, y, z] -> case fdf (v) of df -> case dot (df, x) of x -> [[x, y, z], v] esac esac
  esac
}

public fun onSnd (arr, df) {
  case arr of
    [x, y]    -> case dot (df, y) of y -> [x, y]    esac
  | [x, y, z] -> case dot (df, y) of y -> [x, y, z] esac
  esac
}

public fun fromSnd (arr, df) {
  case arr of
    [x, y]    -> case dot (df, y) of [y, v] -> [[x, y],    v] esac
  | [x, y, z] -> case dot (df, y) of [y, v] -> [[x, y, z], v] esac
  esac
}

public fun intoSnd ([arr, v], fdf) {
  case arr of
    [x, y] ->    case fdf (v) of df -> case dot (df, y) of y -> [x, y]    esac esac
  | [x, y, z] -> case fdf (v) of df -> case dot (df, y) of y -> [x, y, z] esac esac
  esac
}

public fun overSnd ([arr, v], fdf) {
  case arr of
    [x, y]    -> case fdf (v) of [df, v] -> case dot (df, y) of y -> [[x, y], v]    esac esac
  | [x, y, z] -> case fdf (v) of [df, v] -> case dot (df, y) of y -> [[x, y, z], v] esac esac
  esac
}

public fun acrossSnd ([arr, v], fdf) {
  case arr of
    [x, y]    -> case fdf (v) of df -> case dot (df, y) of [y, v] -> [[x, y], v]    esac esac
  | [x, y, z] -> case fdf (v) of df -> case dot (df, y) of [y, v] -> [[x, y, z], v] esac esac
  esac
}

public fun underSnd ([arr, v], fdf) {
  case arr of
    [x, y]    -> case fdf (v) of df -> case dot (df, y) of y -> [[x, y], v]    esac esac
  | [x, y, z] -> case fdf (v) of df -> case dot (df, y) of y -> [[x, y, z], v] esac esac
  esac
}

public fun trd (arr) {
  case arr of
    [x, y, z] -> z
  esac
}

public fun onTrd (arr, df) {
  case arr of
    [x, y, z] -> case dot (df, z) of z -> [x, y, z] esac
  esac
}

public fun fromTrd (arr, df) {
  case arr of
    [x, y, z] -> case dot (df, z) of [z, v] -> [[x, y, z], v] esac
  esac
}

public fun intoTrd ([arr, v], fdf) {
  case arr of
    [x, y, z] -> case fdf (v) of df -> case dot (df, z) of z -> [x, y, z] esac esac
  esac
}

public fun overTrd ([arr, v], fdf) {
  case arr of
    [x, y, z] -> case fdf (v) of [df, v] -> case dot (df, z) of z -> [[x, y, z], v] esac esac
  esac
}

public fun acrossTrd ([arr, v], fdf) {
  case arr of
    [x, y, z] -> case fdf (v) of df -> case dot (df, z) of [z, v] -> [[x, y, z], v] esac esac
  esac
}

public fun underTrd ([arr, v], fdf) {
  case arr of
    [x, y, z] -> case fdf (v) of df -> case dot (df, z) of z -> [[x, y, z], v] esac esac
  esac
}

public fun on (x, df) {
  dot (df, x)
}

public fun from (x, df) {
  dot (df, x)
}

public fun into ([x, v], fdf) {
  dot (fdf (v), x)
}

public fun over ([x, v], fdf) {
  case fdf (v) of [df, v] -> [dot (df, x), v] esac
}

public fun across ([x, v], fdf) {
  dot (fdf (v), x)
}

public fun under ([x, v], fdf) {
  [dot (fdf (v), x), v]
}

public fun fmap ([x, v], f) {
  onFst ([x, v], f)
}

public fun smap ([x, v], f) {
  onSnd ([x, v], f)
}

public fun apply (x) {
  fun (df) {
    dot (df, x)
  }
}

public fun curry (f) {
  fun (x) {
    fun (y) {
      f (x, y)
    }
  }
}

public fun halfCurry (f, x) {
  fun (y) {
    f (x, y)
  }
}

public fun flip (f) {
  fun (x, y) {
    f (y, x)
  }
}

public fun curryFlip (f) {
  fun (y) {
    fun (x) {
      f (x, y)
    }
  }
}

public fun halfCurryFlip (f, y) {
  fun (x) {
    f (x, y)
  }
}

public fun dot (funcOrPair, x) {
  case funcOrPair of
    [f, y] -> f (x, y)
  | [f, y, z] -> f (x, y, z)
  | f      -> f (x)
  esac
}

public infixr >> after * (df, dg) {
  fun (x) {
    dot (dg, dot (df, x))
  }
}

public infix >>= after * (df, fdg) {
  fun (x) {
    into (dot (df, x), fdg)
  }
}

public infix =<< after * (fdg, df) {
  df >>= fdg
}

public infixr :>> after * (df, dg) {
  fun (x) {
    case dot (df, x) of [x, v] -> case dot (dg, x) of [x, vs] -> [x, v:vs] esac esac
  }
}

fun id (x) {
  x
}

public fun const (x) {
  fun (_) {
    x
  }
}

public fun swap ([x, y]) {
  [y, x]
}

public fun bool (b, t, e) {
  if b then t else e fi
}

public fun maybe (mValue, f, default) {
  case mValue of
    Some (value) -> f (value)
  | None -> default
  esac
}

public fun fromMaybe (mValue, default) {
  maybe (mValue, id, default)
}

public fun withNone (x) {
  [x, None]
}

public fun withSome (x, y) {
  [x, Some (y)]
}

public fun with (x, y) {
  [x, y]
}

public fun withFunc (x, f) {
  [x, f (x)]
}

public fun withNull (x) {
  [x, {}]
}

public fun cons (x) {
  fun (xs) {
    x : xs
  }
}

public fun split1 (x:xs) {
  [xs, x]
}

public fun split2 (x1:x2:xs) {
  [xs, [x1, x2]]
}
