-- Helpful functions

import Fun;
import List;
import Array;
import Collection;

public fun createData (fields) {
  case fields of
    [n1, v1, n2, v2] ->
      [listMap ({[n1, v1], [n2, v2]}, compare)]
  | [n1, v1, n2, v2, n3, v3] ->
      [listMap ({[n1, v1], [n2, v2], [n3, v3]}, compare)]
  | [n1, v1, n2, v2, n3, v3, n4, v4] ->
      [listMap ({[n1, v1], [n2, v2], [n3, v3], [n4, v4]}, compare)]
  | [n1, v1, n2, v2, n3, v3, n4, v4, n5, v5] ->
      [listMap ({[n1, v1], [n2, v2], [n3, v3], [n4, v4], [n5, v5]}, compare)]
  | [n1, v1, n2, v2, n3, v3, n4, v4, n5, v5, n6, v6] ->
      [listMap ({[n1, v1], [n2, v2], [n3, v3], [n4, v4], [n5, v5], [n6, v6]}, compare)]
  esac
}

fun getData ([data], fn) {
  case findMap (data, fn) of Some (value) -> value esac
}

fun getAndRemoveData ([data], fn) {
  [[removeMap (data, fn)], getData ([data], fn)]
}

fun updateData ([data], fn, df) {
  [case getAndRemoveData ([data], fn) of [[data2], value] -> addMap (data2, fn, dot (df, value)) esac]
}

fun viewAndUpdateData ([data], fn, df) {
  case getAndRemoveData ([data], fn) of [[data2], value] -> case dot (df, value) of [value2, result] -> [[addMap (data2, fn, value2)], result] esac esac
}

public fun gets (metadata, fn, df) {
  case metadata of
    [data, _] -> dot (df, getData (data, fn))
  | data      -> dot (df, getData (data, fn))
  esac
}

public fun view (metadata, fn, df) {
  case metadata of
    [data, _] -> [data, dot (df, getData (data, fn))]
  | data      -> [data, dot (df, getData (data, fn))]
  esac
}

fun onAll (metadata, df) {
  case metadata of
    [data, v] -> [dot (df, data), v]
  | data      ->  dot (df, data)
  esac
}

public fun on (metadata, fn, df) {
  case metadata of
    [data, v] -> [updateData (data, fn, df), v]
  | data      ->  updateData (data, fn, df)
  esac
}

public fun from (metadata, fn, df) {
  case metadata of
    [data, _] -> viewAndUpdateData (data, fn, df)
  | data      -> viewAndUpdateData (data, fn, df)
  esac
}

public fun intoAll ([data, v], ddf) {
  dot (dot (ddf, v), data)
}

public fun into ([data, v], fn, ddf) {
  updateData (data, fn, dot (ddf, v))
}

public fun under ([data, v], fn, ddf) {
  [updateData (data, fn, dot (ddf, v)), v]
}

public fun just (metadata, fn, df) {
  case metadata of
    [data, v] -> dot (df, getData (data, fn)); [data, v]
  | data      -> dot (df, getData (data, fn)); data
  esac
}

public fun fmap ([data, v], df) {
  [data, dot (df, v)]
}

public fun apply (x) {
  fun (df) {
    dot (df, x)
  }
}

public fun curry (f) {
  fun (x) {
    fun (y) {
      f (x, y)
    }
  }
}

public fun halfCurry (f, x) {
  fun (y) {
    f (x, y)
  }
}

public fun flip (f) {
  fun (x, y) {
    f (y, x)
  }
}

public fun curryFlip (f) {
  fun (y) {
    fun (x) {
      f (x, y)
    }
  }
}

public fun halfCurryFlip (f, y) {
  fun (x) {
    f (x, y)
  }
}

public fun dot (df, x) {
  case df of
    [f, y]       -> f (x, y)
  | [f, y, z]    -> f (x, y, z)
  | [f, y, z, w] -> f (x, y, z, w)
  | f            -> f (x)
  esac
}

public infixl >> after * (df, dg) {
  fun (x) {
    dot (dg, dot (df, x))
  }
}

public infixl >>= after * (df, ddg) {
  fun (x) {
    intoAll (dot (df, x), ddg)
  }
}

public infix =<< after * (fdg, df) {
  df >>= fdg
}

public infixl >>: after * (df, dg) {
  df >>= fun (vs) { dg >>= fun (v) { return (v : vs) } }
}

public infixr :>> after * (df, dg) {
  df >>= fun (v) { dg >>= fun (vs) { return (v : vs) } }
}

public fun traverse_ (ddf, xs) {
  fun (x_) {
    foldl (
      fun (acc, x) {
        dot (dot (ddf, x), acc)
      },
      x_,
      xs
    )
  }
}

public fun traverse (ddf, xs) {
  fun (x_) {
    fmap (foldl (
      fun ([d1, vs], x) {
        case dot (dot (ddf, x), d1) of [d2, v] ->
          [d2, v : vs]
        esac
      },
      [x_, {}],
      xs
    ), reverse)
  }
}

public fun sequence_ (dfs) {
  traverse_ (id, dfs)
}

public fun sequence (dfs) {
  traverse (id, dfs)
}

public fun replicateM_ (n, m) {
  sequence_ (replicate (n, m))
}

public fun replicateM (n, m) {
  sequence (replicate (n, m))
}

public fun foldM (fdf, z, xs) {
  fun (x_) {
    foldl (
      fun ([d1, w], x) {
        dot (fdf (w, x), d1)
      },
      [x_, z],
      xs)
  }
}

public fun const (x) {
  fun (_) {
    x
  }
}

public fun swap ([x, y]) {
  [y, x]
}

public fun bool (b, t, e) {
  if b then t else e fi
}

public fun maybe (mValue, df, default) {
  case mValue of
    Some (value) -> dot (df, value)
  | None -> default
  esac
}

public fun fromMaybe (mValue, default) {
  maybe (mValue, id, default)
}

public fun some (value) {
  Some (value)
}

public fun with (x, y) {
  [x, y]
}

public fun ap (f) {
  fun (x) {
    [f, x]
  }
}

public fun return (y) {
  fun (x) {
    [x, y]
  }
}

public fun cons (x) {
  fun (xs) {
    x : xs
  }
}

public fun split1 (x:xs) {
  [xs, x]
}

public fun split2 (x1:x2:xs) {
  [xs, [x1, x2]]
}

public fun split3 (x1:x2:x3:xs) {
  [xs, [x1, x2, x3]]
}

public fun doM (metadata, df) {
  dot (df, metadata)
}

public fun void (df) {
  fun (x) {
    fst (dot (df, x))
  }
}

public fun pass (metadata, runnable) {
  runnable (metadata);
  metadata
}

public fun byIdx (list, i) {
  fun inner (i, x:xs) {
    if i == 0
    then x
    else inner (i-1, xs)
    fi
  }

  inner (i, list)
}

public fun splitN (list, n) {
  fun inner (n, acc, list) {
    if n == 0
    then [list, reverse (acc)]
    else inner (n-1, list.hd : acc, list.tl)
    fi
  }

  inner (n, {}, list)
}

public fun splitWhile (list, p) {
  fun inner (p, acc, list) {
    case list of
      {} ->
        [{}, reverse (acc)]
    | x:xs ->
        if p (x)
        then inner (p, x:acc, xs)
        else [x:xs, reverse (acc)]
        fi
    esac
  }

  inner (p, {}, list)
}

public fun splitWhileSome (list, f) {
  fun inner (f, acc, list) {
    case list of
      {} ->
        [{}, reverse (acc)]
    | x:xs ->
        case f (x) of
          Some (y) -> inner (f, y:acc, xs)
        | None -> [x:xs, reverse (acc)]
        esac
    esac
  }

  inner (f, {}, list)
}

public fun enumerate (list) {
  fun inner (i, acc, list) {
    case list of
      {} -> reverse (acc)
    | x:xs -> inner (i+1, [x, i] : acc, xs)
    esac
  }

  inner (0, {}, list)
}

public fun replicate (n, x) {
  init (n, const (x))
}

public fun init (n, f) {
  fun inner (i, acc) {
    if i < 0
    then acc
    else inner (i-1, f (i) : acc)
    fi
  }

  inner (n-1, {})
}

public fun splitString (s) {
  [s[0], substring (s, 1, length (s) - 1)]
}
