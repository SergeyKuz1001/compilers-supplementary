-- Helpful functions

import Fun;
import List;

fun lensAll (value, f) {
  f (value)
}

fun lensFst_2 ([x, y], f) {
  case f (x) of [x, v] -> [[x, y], v] esac
}

fun lensFst_3 ([x, y, z], f) {
  case f (x) of [x, v] -> [[x, y, z], v] esac
}

fun lensFst_4 ([x, y, z, w], f) {
  case f (x) of [x, v] -> [[x, y, z, w], v] esac
}

fun lensFst_5 ([x, y, z, w, u], f) {
  case f (x) of [x, v] -> [[x, y, z, w, u], v] esac
}

fun lensFst_6 ([x, y, z, w, u, t], f) {
  case f (x) of [x, v] -> [[x, y, z, w, u, t], v] esac
}

fun lensFst_7 ([x, y, z, w, u, t, s], f) {
  case f (x) of [x, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensFst (tuple, f) {
  case tuple of
    [x, y] -> case f (x) of [x, v] -> [[x, y], v] esac
  | [x, y, z] -> case f (x) of [x, v] -> [[x, y, z], v] esac
  | [x, y, z, w] -> case f (x) of [x, v] -> [[x, y, z, w], v] esac
  | [x, y, z, w, u] -> case f (x) of [x, v] -> [[x, y, z, w, u], v] esac
  | [x, y, z, w, u, t] -> case f (x) of [x, v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f (x) of [x, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensSnd_2 ([x, y], f) {
  case f (y) of [y, v] -> [[x, y], v] esac
}

fun lensSnd_3 ([x, y, z], f) {
  case f (y) of [y, v] -> [[x, y, z], v] esac
}

fun lensSnd_4 ([x, y, z, w], f) {
  case f (y) of [y, v] -> [[x, y, z, w], v] esac
}

fun lensSnd_5 ([x, y, z, w, u], f) {
  case f (y) of [y, v] -> [[x, y, z, w, u], v] esac
}

fun lensSnd_6 ([x, y, z, w, u, t], f) {
  case f (y) of [y, v] -> [[x, y, z, w, u, t], v] esac
}

fun lensSnd_7 ([x, y, z, w, u, t, s], f) {
  case f (y) of [y, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensSnd (tuple, f) {
  case tuple of
    [x, y] -> case f (y) of [y, v] -> [[x, y], v] esac
  | [x, y, z] -> case f (y) of [y, v] -> [[x, y, z], v] esac
  | [x, y, z, w] -> case f (y) of [y, v] -> [[x, y, z, w], v] esac
  | [x, y, z, w, u] -> case f (y) of [y, v] -> [[x, y, z, w, u], v] esac
  | [x, y, z, w, u, t] -> case f (y) of [y, v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f (y) of [y, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensTrd_3 ([x, y, z], f) {
  case f (z) of [z, v] -> [[x, y, z], v] esac
}

fun lensTrd_4 ([x, y, z, w], f) {
  case f (z) of [z, v] -> [[x, y, z, w], v] esac
}

fun lensTrd_5 ([x, y, z, w, u], f) {
  case f (z) of [z, v] -> [[x, y, z, w, u], v] esac
}

fun lensTrd_6 ([x, y, z, w, u, t], f) {
  case f (z) of [z, v] -> [[x, y, z, w, u, t], v] esac
}

fun lensTrd_7 ([x, y, z, w, u, t, s], f) {
  case f (z) of [z, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensTrd (tuple, f) {
  case tuple of
    [x, y, z] -> case f (z) of [z, v] -> [[x, y, z], v] esac
  | [x, y, z, w] -> case f (z) of [z, v] -> [[x, y, z, w], v] esac
  | [x, y, z, w, u] -> case f (z) of [z, v] -> [[x, y, z, w, u], v] esac
  | [x, y, z, w, u, t] -> case f (z) of [z, v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f (z) of [z, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensFrt_4 ([x, y, z, w], f) {
  case f (w) of [w, v] -> [[x, y, z, w], v] esac
}

fun lensFrt_5 ([x, y, z, w, u], f) {
  case f (w) of [w, v] -> [[x, y, z, w, u], v] esac
}

fun lensFrt_6 ([x, y, z, w, u, t], f) {
  case f (w) of [w, v] -> [[x, y, z, w, u, t], v] esac
}

fun lensFrt_7 ([x, y, z, w, u, t, s], f) {
  case f (w) of [w, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensFrt (tuple, f) {
  case tuple of
    [x, y, z, w] -> case f (w) of [w, v] -> [[x, y, z, w], v] esac
  | [x, y, z, w, u] -> case f (w) of [w, v] -> [[x, y, z, w, u], v] esac
  | [x, y, z, w, u, t] -> case f (w) of [w, v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f (w) of [w, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensFft_5 ([x, y, z, w, u], f) {
  case f (u) of [u, v] -> [[x, y, z, w, u], v] esac
}

fun lensFft_6 ([x, y, z, w, u, t], f) {
  case f (u) of [u, v] -> [[x, y, z, w, u, t], v] esac
}

fun lensFft_7 ([x, y, z, w, u, t, s], f) {
  case f (u) of [u, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensFft (tuple, f) {
  case tuple of
    [x, y, z, w, u] -> case f (u) of [u, v] -> [[x, y, z, w, u], v] esac
  | [x, y, z, w, u, t] -> case f (u) of [u, v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f (u) of [u, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensSxt_6 ([x, y, z, w, u, t], f) {
  case f (t) of [t, v] -> [[x, y, z, w, u, t], v] esac
}

fun lensSxt_7 ([x, y, z, w, u, t, s], f) {
  case f (t) of [t, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensSxt (tuple, f) {
  case tuple of
    [x, y, z, w, u, t] -> case f (t) of [t, v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f (t) of [t, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensSvt_7 ([x, y, z, w, u, t, s], f) {
  case f (s) of [s, v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensSvt (tuple, f) {
  case tuple of
    [x, y, z, w, u, t, s] -> case f (s) of [s, v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensWithoutFst_3 ([x, y, z], f) {
  case f ([y, z]) of [[y, z], v] -> [[x, y, z], v] esac
}

fun lensWithoutFst_4 ([x, y, z, w], f) {
  case f ([y, z, w]) of [[y, z, w], v] -> [[x, y, z, w], v] esac
}

fun lensWithoutFst_5 ([x, y, z, w, u], f) {
  case f ([y, z, w, u]) of [[y, z, w, u], v] -> [[x, y, z, w, u], v] esac
}

fun lensWithoutFst_6 ([x, y, z, w, u, t], f) {
  case f ([y, z, w, u, t]) of [[y, z, w, u, t], v] -> [[x, y, z, w, u, t], v] esac
}

fun lensWithoutFst_7 ([x, y, z, w, u, t, s], f) {
  case f ([y, z, w, u, t, s]) of [[y, z, w, u, t, s], v] -> [[x, y, z, w, u, t, s], v] esac
}

fun lensWithoutFst (tuple, f) {
  case tuple of
    [x, y, z] -> case f ([y, z]) of [[y, z], v] -> [[x, y, z], v] esac
  | [x, y, z, w] -> case f ([y, z, w]) of [[y, z, w], v] -> [[x, y, z, w], v] esac
  | [x, y, z, w, u] -> case f ([y, z, w, u]) of [[y, z, w, u], v] -> [[x, y, z, w, u], v] esac
  | [x, y, z, w, u, t] -> case f ([y, z, w, u, t]) of [[y, z, w, u, t], v] -> [[x, y, z, w, u, t], v] esac
  | [x, y, z, w, u, t, s] -> case f ([y, z, w, u, t, s]) of [[y, z, w, u, t, s], v] -> [[x, y, z, w, u, t, s], v] esac
  esac
}

fun lensHead (x : xs, f) {
  case f (x) of [x, v] -> [x : xs, v] esac
}

fun lensTail (x : xs , f) {
  case f (xs) of [xs, v] -> [x : xs, v] esac
}

fun lensData (Data (ls, vs), f) {
  case f (vs) of [vs, r] -> [Data (ls, vs), r] esac
}

infixr >-> after * (l1, l2) {
  fun (value, f) {
    l1 (value, fun (subvalue) {
      l2 (subvalue, f)
    })
  }
}

fun lensByName0 (n) {
  case n of
    "all"  -> lensAll
  | "fst"  -> lensFst
  | "snd"  -> lensSnd
  | "trd"  -> lensTrd
  | "frt"  -> lensFrt
  | "fft"  -> lensFft
  | "sxt"  -> lensSxt
  | "svt"  -> lensSvt
  | "head" -> lensHead
  | "tail" -> lensTail
  | n      -> fun (data, f) { data [0] (n) (data, f) }
  esac
}

fun lensByName (ns) {
  case ns of
    [n1, n2] -> lensByName0 (n1) >-> lensByName0 (n2)
  | [n1, n2, n3] -> lensByName0 (n1) >-> lensByName0 (n2) >-> lensByName0 (n3)
  | n -> lensByName0 (n)
  esac
}

public fun createData (fields) {
  case fields of
    [n1, v1, n2, v2] -> [
      fun (n) {
        if compare (n, "raw") == 0 then lensWithoutFst_3
        elif compare (n,  n1) == 0 then lensSnd_3
        elif compare (n,  n2) == 0 then lensTrd_3
        else failure ("unknown name of field: %s", n)
        fi
      },
      v1, v2]
  | [n1, v1, n2, v2, n3, v3] -> [
      fun (n) {
        if compare (n, "raw") == 0 then lensWithoutFst_4
        elif compare (n,  n1) == 0 then lensSnd_4
        elif compare (n,  n2) == 0 then lensTrd_4
        elif compare (n,  n3) == 0 then lensFrt_4
        else failure ("unknown name of field: %s", n)
        fi
      },
      v1, v2, v3]
  | [n1, v1, n2, v2, n3, v3, n4, v4] -> [
      fun (n) {
        if compare (n, "raw") == 0 then lensWithoutFst_5
        elif compare (n,  n1) == 0 then lensSnd_5
        elif compare (n,  n2) == 0 then lensTrd_5
        elif compare (n,  n3) == 0 then lensFrt_5
        elif compare (n,  n4) == 0 then lensFft_5
        else failure ("unknown name of field: %s", n)
        fi
      },
      v1, v2, v3, v4]
  | [n1, v1, n2, v2, n3, v3, n4, v4, n5, v5] -> [
      fun (n) {
        if compare (n, "raw") == 0 then lensWithoutFst_6
        elif compare (n,  n1) == 0 then lensSnd_6
        elif compare (n,  n2) == 0 then lensTrd_6
        elif compare (n,  n3) == 0 then lensFrt_6
        elif compare (n,  n4) == 0 then lensFft_6
        elif compare (n,  n5) == 0 then lensSxt_6
        else failure ("unknown name of field: %s", n)
        fi
      },
      v1, v2, v3, v4, v5]
  | [n1, v1, n2, v2, n3, v3, n4, v4, n5, v5, n6, v6] -> [
      fun (n) {
        if compare (n, "raw") == 0 then lensWithoutFst_7
        elif compare (n,  n1) == 0 then lensSnd_7
        elif compare (n,  n2) == 0 then lensTrd_7
        elif compare (n,  n3) == 0 then lensFrt_7
        elif compare (n,  n4) == 0 then lensFft_7
        elif compare (n,  n5) == 0 then lensSxt_7
        elif compare (n,  n6) == 0 then lensSvt_7
        else failure ("unknown name of field: %s", n)
        fi
      },
      v1, v2, v3, v4, v5, v6]
  esac
}

public fun gets (metadata, fn, df) {
  case metadata of
    [data, _] -> snd (lensByName (fn) (data, fun (x) { [x, dot (df, x)] }))
  | data      -> snd (lensByName (fn) (data, fun (x) { [x, dot (df, x)] }))
  esac
}

public fun view (metadata, fn, df) {
  case metadata of
    [data, _] -> lensByName (fn) (data, fun (x) { [x, dot (df, x)] })
  | data      -> lensByName (fn) (data, fun (x) { [x, dot (df, x)] })
  esac
}

fun onAll (metadata, df) {
  case metadata of
    [data, v] -> [dot (df, data), v]
  | data      -> dot (df, data)
  esac
}

public fun on (metadata, fn, df) {
  case metadata of
    [data, v] -> lensByName (fn) (data, fun (x) { [dot (df, x), v] })
  | data      -> fst (lensByName (fn) (data, fun (x) { [dot (df, x), 0] }))
  esac
}

public fun from (metadata, fn, df) {
  case metadata of
    [data, _] -> lensByName (fn) (data, fun (x) { dot (df, x) })
  | data      -> lensByName (fn) (data, fun (x) { dot (df, x) })
  esac
}

public fun smartFrom (metadata, fn, df) {
  case
    case metadata of
      [data, v : vs] -> [data, fun ([data, v_]) { [data, v_ : v : vs] }]
    | [data, {}]     -> [data, fun ([data, v_]) { [data, v_ : {}] }]
    | [data, v]      -> [data, fun ([data, v_]) { [data, v_ : v : {}] }]
    | data           -> [data, fun ([data, v_]) { [data, v_] }]
    esac of [data, wrapper] ->
      lensByName (fn) (data, fun (x) { wrapper (dot (df, x)) })
  esac
}

fun intoAll ([data, v], ddf) {
  dot (dot (ddf, v), data)
}

public fun into ([data, v], fn, ddf) {
  fst (lensByName (fn) (data, fun (x) { [dot (dot (ddf, v), x), 0] }))
}

public fun across ([data, v], fn, ddf) {
  lensByName (fn) (data, fun (x) { dot (dot (ddf, v), x) })
}

public fun under ([data, v], fn, ddf) {
  lensByName (fn) (data, fun (x) { [dot (dot (ddf, v), x), v] })
}

public fun just (metadata, fn, df) {
  case metadata of
    [data, v] -> lensByName (fn) (data, fun (x) { dot (df, x); [x, v] })
  | data      -> fst (lensByName (fn) (data, fun (x) { dot (df, x); [x, 0] }))
  esac
}

public fun fmap ([data, v], df) {
  [data, dot (df, v)]
}

public fun apply (x) {
  fun (df) {
    dot (df, x)
  }
}

public fun curry (f) {
  fun (x) {
    fun (y) {
      f (x, y)
    }
  }
}

public fun halfCurry (f, x) {
  fun (y) {
    f (x, y)
  }
}

public fun flip (f) {
  fun (x, y) {
    f (y, x)
  }
}

public fun curryFlip (f) {
  fun (y) {
    fun (x) {
      f (x, y)
    }
  }
}

public fun halfCurryFlip (f, y) {
  fun (x) {
    f (x, y)
  }
}

public fun dot (df, x) {
  case df of
    [f, y]       -> f (x, y)
  | [f, y, z]    -> f (x, y, z)
  | [f, y, z, w] -> f (x, y, z, w)
  | f            -> f (x)
  esac
}

public infixl >> after * (df, dg) {
  fun (x) {
    dot (dg, dot (df, x))
  }
}

public infixl >>= after * (df, ddg) {
  fun (x) {
    intoAll (dot (df, x), ddg)
  }
}

public infix =<< after * (fdg, df) {
  df >>= fdg
}

public infixl >>: after * (df, dg) {
  df >>= fun (vs) { dg >>= fun (v) { [return, v : vs] } }
}

public infixr :>> after * (df, dg) {
  df >>= fun (v) { dg >>= fun (vs) { [return, v : vs] } }
}

public fun traverse_ (ddf, xs) {
  fun (x_) {
    foldl (
      fun (acc, x) {
        dot (dot (ddf, x), acc)
      },
      x_,
      xs
    )
  }
}

public fun traverse (ddf, xs) {
  fun (x_) {
    fmap (foldl (
      fun ([d1, vs], x) {
        case dot (dot (ddf, x), d1) of [d2, v] ->
          [d2, v : vs]
        esac
      },
      [x_, {}],
      xs
    ), reverse)
  }
}

public fun sequence_ (dfs) {
  traverse_ (id, dfs)
}

public fun sequence (dfs) {
  traverse (id, dfs)
}

public fun replicateM_ (n, m) {
  sequence_ (replicate (n, m))
}

public fun replicateM (n, m) {
  sequence (replicate (n, m))
}

public fun const (x) {
  fun (_) {
    x
  }
}

public fun swap ([x, y]) {
  [y, x]
}

public fun bool (b, t, e) {
  if b then t else e fi
}

public fun maybe (mValue, df, default) {
  case mValue of
    Some (value) -> dot (df, value)
  | None -> default
  esac
}

public fun fromMaybe (mValue, default) {
  maybe (mValue, id, default)
}

public fun some (value) {
  Some (value)
}

public fun with (x, y) {
  [x, y]
}

public fun ap (f) {
  fun (x) {
    [f, x]
  }
}

public fun return (x, y) {
  [x, y]
}

public fun cons (x) {
  fun (xs) {
    x : xs
  }
}

public fun split1 (x:xs) {
  [xs, x]
}

public fun split2 (x1:x2:xs) {
  [xs, [x1, x2]]
}

public fun doM (metadata, df) {
  dot (df, metadata)
}

public fun void (df) {
  fun (x) {
    fst (dot (df, x))
  }
}

public fun pass (metadata, runnable) {
  runnable ();
  metadata
}

public fun splitN (list, n) {
  fun inner (n, acc, list) {
    if n == 0
    then [list, reverse (acc)]
    else inner (n-1, list.hd : acc, list.tl)
    fi
  }

  inner (n, {}, list)
}

public fun splitWhile (list, p) {
  fun inner (p, acc, list) {
    case list of
      {} ->
        [{}, reverse (acc)]
    | x:xs ->
        if p (x)
        then inner (p, x:acc, xs)
        else [x:xs, reverse (acc)]
        fi
    esac
  }

  inner (p, {}, list)
}

public fun splitWhileSome (list, f) {
  fun inner (f, acc, list) {
    case list of
      {} ->
        [{}, reverse (acc)]
    | x:xs ->
        case f (x) of
          Some (y) -> inner (f, y:acc, xs)
        | None -> [x:xs, reverse (acc)]
        esac
    esac
  }

  inner (f, {}, list)
}

public fun enumerate (list) {
  fun inner (i, list) {
    case list of
      {} -> {}
    | x:xs -> [x, i] : inner (i+1, xs)
    esac
  }

  inner (0, list)
}

public fun replicate (n, x) {
  fun inner (n, acc) {
    if n <= 0
    then acc
    else inner (n-1, x : acc)
    fi
  }

  inner (n, {})
}
